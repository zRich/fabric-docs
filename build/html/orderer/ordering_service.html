

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Ordering Service &mdash; hyperledger-fabricdocs master documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Private data" href="../private-data/private-data.html" />
    <link rel="prev" title="Ledger" href="../ledger/ledger.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          


          
            <a href="../index.html" class="icon icon-home"> hyperledger-fabricdocs
          

          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

<br><img style="background-color: #fff; height: unset; width: unset;" alt="Hyperledger Fabric" src=../_images/hyperledger_fabric_logo_color.png />
<br>
<a href="https://github.com/hyperledger/fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="GitHub" src="../_static/images/github_button.png"/></a>
&nbsp;<a href="https://stackoverflow.com/questions/tagged/hyperledger-fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="StackOverflow" src="../_static/images/stackoverflow_button.png"/></a>
&nbsp;<a href="https://chat.hyperledger.org"><img style="padding: 0px; margin: auto auto auto auto;" alt="Rocket Chat" src="../_static/images/rocketchat_button.png"/></a>
&nbsp;<a href="https://www.youtube.com/playlist?list=PL0MZ85B_96CH7wvtrRzV7SvtRY0sI0DEg"><img style="padding: 0px; margin: auto auto auto auto;" alt="Youtube Channel" src="../_static/images/youtube_button.png"/></a>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../whatis.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew.html">What’s new in the v2.0 Alpha</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew.html#release-notes">Release notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../key_concepts.html">Key Concepts</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../blockchain.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functionalities.html">Hyperledger Fabric Functionalities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fabric_model.html">Hyperledger Fabric Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/network.html">Blockchain network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../identity/identity.html">Identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../membership/membership.html">Membership</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peers/peers.html">Peers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smartcontract/smartcontract.html">Smart Contracts and Chaincode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ledger/ledger.html">Ledger</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Ordering Service</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-ordering">What is ordering?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#orderer-nodes-and-channel-configuration">Orderer nodes and channel configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#orderer-nodes-and-identity">Orderer nodes and Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#orderers-and-the-transaction-flow">Orderers and the transaction flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#phase-one-proposal">Phase one: Proposal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phase-two-ordering-and-packaging-transactions-into-blocks">Phase two: Ordering and packaging transactions into blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phase-three-validation-and-commit">Phase three: Validation and commit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ordering-service-implementations">Ordering service implementations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solo">Solo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raft">Raft</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#raft-concepts">Raft concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#raft-in-a-transaction-flow">Raft in a transaction flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#architectural-notes">Architectural notes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kafka">Kafka</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../private-data/private-data.html">Private data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases.html">Use Cases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developapps/developing_applications.html">Developing Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ops_guide.html">Operations Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../command_ref.html">Commands Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Fabric-FAQ.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../questions.html">Still Have Questions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status.html">Status</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">hyperledger-fabricdocs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../key_concepts.html">Key Concepts</a> &raquo;</li>
        
      <li>The Ordering Service</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/orderer/ordering_service.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-ordering-service">
<h1>The Ordering Service<a class="headerlink" href="#the-ordering-service" title="Permalink to this headline">¶</a></h1>
<p><strong>Audience:</strong> Architects, ordering service admins, channel creators</p>
<p>This topic serves as a conceptual introduction to the concept of ordering, how
orderers interact with peers, the role they play in a transaction flow, and an
overview of the currently available implementations of the ordering service,
with a particular focus on the <strong>Raft</strong> ordering service implementation.</p>
<div class="section" id="what-is-ordering">
<h2>What is ordering?<a class="headerlink" href="#what-is-ordering" title="Permalink to this headline">¶</a></h2>
<p>Many distributed blockchains, such as Ethereum and Bitcoin, are not permissioned,
which means that any node can participate in the consensus process, wherein
transactions are ordered and bundled into blocks. Because of this fact, these
systems rely on <strong>probabilistic</strong> consensus algorithms which eventually
guarantee ledger consistency to a high degree of probability, but which are
still vulnerable to divergent ledgers (also known as a ledger “fork”), where
different participants in the network have a different view of the accepted
order of transactions.</p>
<p>Hyperledger Fabric works differently. It features a kind of a node called an
<strong>orderer</strong> (it’s also known as an “ordering node”) that does this transaction
ordering, which along with other nodes forms an <strong>ordering service</strong>. Because
Fabric’s design relies on <strong>deterministic</strong> consensus algorithms, any block a
peer validates as generated by the ordering service is guaranteed to be final
and correct. Ledgers cannot fork the way they do in many other distributed
blockchains.</p>
<p>In addition to promoting finality, separating the endorsement of chaincode
execution (which happens at the peers) from ordering gives Fabric advantages
in performance and scalability, eliminating bottlenecks which can occur when
execution and ordering are performed by the same nodes.</p>
</div>
<div class="section" id="orderer-nodes-and-channel-configuration">
<h2>Orderer nodes and channel configuration<a class="headerlink" href="#orderer-nodes-and-channel-configuration" title="Permalink to this headline">¶</a></h2>
<p>In addition to their <strong>ordering</strong> role, orderers also maintain the list of
organizations that are allowed to create channels. This list of organizations is
known as the “consortium”, and the list itself is kept in the configuration of
the “orderer system channel” (also known as the “ordering system channel”). By
default, this list, and the channel it lives on, can only be edited by the
orderer admin. Note that it is possible for an ordering service to hold several
of these lists, which makes the consortium a vehicle for Fabric multi-tenancy.</p>
<p>Orderers also enforce basic access control for channels, restricting who can
read and write data to them, and who can configure them. Remember that who
is authorized to modify a configuration element in a channel is subject to the
policies that the relevant administrators set when they created the consortium
or the channel. Configuration transactions are processed by the orderer,
as it needs to know the current set of policies to execute its basic
form of access control. In this case, the orderer processes the
configuration update to make sure that the requestor has the proper
administrative rights. If so, the orderer validates the update request against
the existing configuration, generates a new configuration transaction,
and packages it into a block that is relayed to all peers on the channel. The
peers then processs the configuration transactions in order to verify that the
modifications approved by the orderer do indeed satisfy the policies defined in
the channel.</p>
</div>
<div class="section" id="orderer-nodes-and-identity">
<h2>Orderer nodes and Identity<a class="headerlink" href="#orderer-nodes-and-identity" title="Permalink to this headline">¶</a></h2>
<p>Everything that interacts with a blockchain network, including peers,
applications, admins, and orderers, acquires their organizational identity from
their digital certificate and their Membership Service Provider (MSP) definition.</p>
<p>For more information about identities and MSPs, check out our documentation on
<a class="reference external" href="../identity/identity.html">Identity</a> and <a class="reference external" href="../membership/membership.html">Membership</a>.</p>
<p>Just like peers, ordering nodes belong to an organization. And similar to peers,
a separate Certificate Authority (CA) should be used for each organization.
Whether this CA will function as the root CA, or whether you choose to deploy
a root CA and then intermediate CAs associated with that root CA, is up to you.</p>
</div>
<div class="section" id="orderers-and-the-transaction-flow">
<h2>Orderers and the transaction flow<a class="headerlink" href="#orderers-and-the-transaction-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="phase-one-proposal">
<h3>Phase one: Proposal<a class="headerlink" href="#phase-one-proposal" title="Permalink to this headline">¶</a></h3>
<p>We’ve seen from our topic on <a class="reference external" href="../peers/peers.html">Peers</a> that they form the basis
for a blockchain network, hosting ledgers, which can be queried and updated by
applications through smart contracts.</p>
<p>Specifically, applications that want to update the ledger are involved in a
process with three phases that ensures all of the peers in a blockchain network
keep their ledgers consistent with each other.</p>
<p>In the first phase, a client application sends a transaction proposal to
a subset of peers that will invoke a smart contract to produce a proposed
ledger update and then endorse the results. The endorsing peers do not apply
the proposed update to their copy of the ledger at this time. Instead, the
endorsing peers return a proposal response to the client application. The
endorsed transaction proposals will ultimately be ordered into blocks in phase
two, and then distributed to all peers for final validation and commit in
phase three.</p>
<p>For an in-depth look at the first phase, refer back to the <a class="reference external" href="../peers/peers.html#phase-1-proposal">Peers</a> topic.</p>
</div>
<div class="section" id="phase-two-ordering-and-packaging-transactions-into-blocks">
<h3>Phase two: Ordering and packaging transactions into blocks<a class="headerlink" href="#phase-two-ordering-and-packaging-transactions-into-blocks" title="Permalink to this headline">¶</a></h3>
<p>After the completion of the first phase of a transaction, a client
application has received an endorsed transaction proposal response from a set of
peers. It’s now time for the second phase of a transaction.</p>
<p>In this phase, application clients submit transactions containing endorsed
transaction proposal responses to an ordering service node. The ordering service
creates blocks of transactions which will ultimately be distributed to
all peers on the channel for final validation and commit in phase three.</p>
<p>Ordering service nodes receive transactions from many different application
clients concurrently. These ordering service nodes work together to collectively
form the ordering service. Its job is to arrange batches of submitted transactions
into a well-defined sequence and package them into <em>blocks</em>. These blocks will
become the <em>blocks</em> of the blockchain!</p>
<p>The number of transactions in a block depends on channel configuration
parameters related to the desired size and maximum elapsed duration for a
block (<code class="docutils literal notranslate"><span class="pre">BatchSize</span></code> and <code class="docutils literal notranslate"><span class="pre">BatchTimeout</span></code> parameters, to be exact). The blocks are
then saved to the orderer’s ledger and distributed to all peers that have joined
the channel. If a peer happens to be down at this time, or joins the channel
later, it will receive the blocks after reconnecting to an ordering service
node, or by gossiping with another peer. We’ll see how this block is processed
by peers in the third phase.</p>
<p><img alt="../_images/orderer.diagram.1.png" src="../_images/orderer.diagram.1.png" />Orderer1</p>
<p><em>The first role of an ordering node is to package proposed ledger updates. In
this example, application A1 sends a transaction T1 endorsed by E1 and E2 to
the orderer O1. In parallel, Application A2 sends transaction T2 endorsed by E1
to the orderer O1. O1 packages transaction T1 from application A1 and
transaction T2 from application A2 together with other transactions from other
applications in the network into block B2. We can see that in B2, the
transaction order is T1,T2,T3,T4,T6,T5 – which may not be the order in which
these transactions arrived at the orderer! (This example shows a very
simplified ordering service configuration with only one ordering node.)</em></p>
<p>It’s worth noting that the sequencing of transactions in a block is not
necessarily the same as the order received by the ordering service, since there
can be multiple ordering service nodes that receive transactions at approximately
the same time.  What’s important is that the ordering service puts the transactions
into a strict order, and peers will use this order when validating and committing
transactions.</p>
<p>This strict ordering of transactions within blocks makes Hyperledger Fabric a
little different from other blockchains where the same transaction can be
packaged into multiple different blocks that compete to form a chain.
In Hyperledger Fabric, the blocks generated by the ordering service are
<strong>final</strong>. Once a transaction has been written to a block, its position in the
ledger is immutably assured. As we said earlier, Hyperledger Fabric’s finality
means that there are no <strong>ledger forks</strong> — validated transactions will never
be reverted or dropped.</p>
<p>We can also see that, whereas peers execute smart contracts and process transactions,
orderers most definitely do not. Every authorized transaction that arrives at an
orderer is mechanically packaged in a block — the orderer makes no judgement
as to the content of a transaction (except for channel configuration transactions,
as mentioned earlier).</p>
<p>At the end of phase two, we see that orderers have been responsible for the simple
but vital processes of collecting proposed transaction updates, ordering them,
and packaging them into blocks, ready for distribution.</p>
</div>
<div class="section" id="phase-three-validation-and-commit">
<h3>Phase three: Validation and commit<a class="headerlink" href="#phase-three-validation-and-commit" title="Permalink to this headline">¶</a></h3>
<p>The third phase of the transaction workflow involves the distribution and
subsequent validation of blocks from the orderer to the peers, where they can be
applied to the ledger.</p>
<p>Phase 3 begins with the orderer distributing blocks to all peers connected to
it. It’s also worth noting that not every peer needs to be connected to an orderer —
peers can cascade blocks to other peers using the <a class="reference external" href="../gossip.html"><strong>gossip</strong></a>
protocol.</p>
<p>Each peer will validate distributed blocks independently, but in a deterministic
fashion, ensuring that ledgers remain consistent. Specifically, each peer in the
channel will validate each transaction in the block to ensure it has been endorsed
by the required organization’s peers, that its endorsements match, and that
it hasn’t become invalidated by other recently committed transactions which may
have been in-flight when the transaction was originally endorsed. Invalidated
transactions are still retained in the immutable block created by the orderer,
but they are marked as invalid by the peer and do not update the ledger’s state.</p>
<p><img alt="../_images/orderer.diagram.2.png" src="../_images/orderer.diagram.2.png" />Orderer2</p>
<p><em>The second role of an ordering node is to distribute blocks to peers. In this
example, orderer O1 distributes block B2 to peer P1 and peer P2. Peer P1
processes block B2, resulting in a new block being added to ledger L1 on P1. In
parallel, peer P2 processes block B2, resulting in a new block being added to
ledger L1 on P2. Once this process is complete, the ledger L1 has been
consistently updated on peers P1 and P2, and each may inform connected
applications that the transaction has been processed.</em></p>
<p>In summary, phase three sees the blocks generated by the ordering service applied
consistently to the ledger. The strict ordering of transactions into blocks
allows each peer to validate that transaction updates are consistently applied
across the blockchain network.</p>
<p>For a deeper look at phase 3, refer back to the <a class="reference external" href="../peers/peers.html#phase-3-validation-and-commit">Peers</a> topic.</p>
</div>
</div>
<div class="section" id="ordering-service-implementations">
<h2>Ordering service implementations<a class="headerlink" href="#ordering-service-implementations" title="Permalink to this headline">¶</a></h2>
<p>While every ordering service currently available handles transactions and
configuration updates the same way, there are nevertheless several different
implementations for achieving consensus on the strict ordering of transactions
between ordering service nodes.</p>
<p>For information about how to stand up an ordering node (regardless of the
implementation the node will be used in), check out <a class="reference external" href="../orderer_deploy.html">our documentation on standing up an ordering node</a>.</p>
<ul>
<li><p><strong>Solo</strong></p>
<p>The Solo implementation of the ordering service is aptly named: it features
only a single ordering node. As a result, it is not, and never will be, fault
tolerant. For that reason, Solo implementations cannot be considered for
production, but they are a good choice for testing applications and smart
contracts, or for creating proofs of concept. However, if you ever want to
extend this PoC network into production, you might want to start with a single
node Raft cluster, as it may be reconfigured to add additional nodes.</p>
</li>
<li><p><strong>Raft</strong></p>
<p>New as of v1.4.1, Raft is a crash fault tolerant (CFT) ordering service
based on an implementation of <a class="reference external" href="https://raft.github.io/raft.pdf">Raft protocol</a>
in <a class="reference external" href="https://coreos.com/etcd/"><code class="docutils literal notranslate"><span class="pre">etcd</span></code></a>. Raft follows a “leader and
follower” model, where a leader node is elected (per channel) and its decisions
are replicated by the followers. Raft ordering services should be easier to set
up and manage than Kafka-based ordering services, and their design allows
different organizations to contribute nodes to a distributed ordering service.</p>
</li>
<li><p><strong>Kafka</strong></p>
<p>Similar to Raft-based ordering, Apache Kafka is a CFT implementation that uses
a “leader and follower” node configuration. Kafka utilizes a ZooKeeper
ensemble for management purposes. The Kafka based ordering service has been
available since Fabric v1.0, but many users may find the additional
administrative overhead of managing a Kafka cluster intimidating or undesirable.</p>
</li>
</ul>
</div>
<div class="section" id="solo">
<h2>Solo<a class="headerlink" href="#solo" title="Permalink to this headline">¶</a></h2>
<p>As stated above, a Solo ordering service is a good choice when developing test,
development, or proofs-of-concept networks. For that reason, it is the default
ordering service deployed in our <a class="reference external" href="../build_network.html">Build your first network tutorial</a>),
as, from the perspective of other network components, a Solo ordering service
processes transactions identically to the more elaborate Kafka and Raft
implementations while saving on the administrative overhead of maintaining and
upgrading multiple nodes and clusters. Because a Solo ordering service is not
crash-fault tolerant, it should never be considered a viable alternative for a
production blockchain network. For networks which wish to start with only a
single ordering node but might wish to grow in the future, a single node Raft
cluster is a better option.</p>
</div>
<div class="section" id="raft">
<h2>Raft<a class="headerlink" href="#raft" title="Permalink to this headline">¶</a></h2>
<p>For information on how to configure a Raft ordering service, check out our
<a class="reference external" href="../raft_configuration.html">documentation on configuring a Raft ordering service</a>.</p>
<p>The go-to ordering service choice for production networks, the Fabric
implementation of the established Raft protocol uses a “leader and follower”
model, in which a leader is dynamically elected among the ordering
nodes in a channel (this collection of nodes is known as the “consenter set”),
and that leader replicates messages to the follower nodes. Because the system
can sustain the loss of nodes, including leader nodes, as long as there is a
majority of ordering nodes (what’s known as a “quorum”) remaining, Raft is said
to be “crash fault tolerant” (CFT). In other words, if there are three nodes in a
channel, it can withstand the loss of one node (leaving two remaining). If you
have five nodes in a channel, you can lose two nodes (leaving three
remaining nodes).</p>
<p>From the perspective of the service they provide to a network or a channel, Raft
and the existing Kafka-based ordering service (which we’ll talk about later) are
similar. They’re both CFT ordering services using the leader and follower
design. If you are an application developer, smart contract developer, or peer
administrator, you will not notice a functional difference between an ordering
service based on Raft versus Kafka. However, there are a few major differences worth
considering, especially if you intend to manage an ordering service:</p>
<ul class="simple">
<li><p>Raft is easier to set up. Although Kafka has scores of admirers, even those
admirers will (usually) admit that deploying a Kafka cluster and its ZooKeeper
ensemble can be tricky, requiring a high level of expertise in Kafka
infrastructure and settings. Additionally, there are many more components to
manage with Kafka than with Raft, which means that there are more places where
things can go wrong. And Kafka has its own versions, which must be coordinated
with your orderers. <strong>With Raft, everything is embedded into your ordering node</strong>.</p></li>
<li><p>Kafka and Zookeeper are not designed to be run across large networks. They are
designed to be CFT but should be run in a tight group of hosts. This means that
practically speaking you need to have one organization run the Kafka cluster.
Given that, having ordering nodes run by different organizations when using Kafka
(which Fabric supports) doesn’t give you much in terms of decentralization because
the nodes will all go to the same Kafka cluster which is under the control of a
single organization. With Raft, each organization can have its own ordering
nodes, participating in the ordering service, which leads to a more decentralized
system.</p></li>
<li><p>Raft is supported natively. While Kafka-based ordering services are currently
compatible with Fabric, users are required to get the requisite images and
learn how to use Kafka and ZooKeeper on their own. Likewise, support for
Kafka-related issues is handled through <a class="reference external" href="https://kafka.apache.org/">Apache</a>, the
open-source developer of Kafka, not Hyperledger Fabric. The Fabric Raft implementation,
on the other hand, has been developed and will be supported within the Fabric
developer community and its support apparatus.</p></li>
<li><p>Where Kafka uses a pool of servers (called “Kafka brokers”) and the admin of
the orderer organization specifies how many nodes they want to use on a
particular channel, Raft allows the users to specify which ordering nodes will
be deployed to which channel. In this way, peer organizations can make sure
that, if they also own an orderer, this node will be made a part of a ordering
service of that channel, rather than trusting and depending on a central admin
to manage the Kafka nodes.</p></li>
<li><p>Raft is the first step toward Fabric’s development of a byzantine fault tolerant
(BFT) ordering service. As we’ll see, some decisions in the development of
Raft were driven by this. If you are interested in BFT, learning how to use
Raft should ease the transition.</p></li>
</ul>
<p><strong>Note: Similar to Solo and Kafka, a Raft ordering service can lose transactions
after acknowledgement of receipt has been sent to a client. For example, if the
leader crashes at approximately the same time as a follower provides
acknowledgement of receipt. Therefore, application clients should listen on peers
for transaction commit events regardless (to check for transaction validity), but
extra care should be taken to ensure that the client also gracefully tolerates a
timeout in which the transaction does not get committed in a configured timeframe.
Depending on the application, it may be desirable to resubmit the transaction or
collect a new set of endorsements upon such a timeout.</strong></p>
<div class="section" id="raft-concepts">
<h3>Raft concepts<a class="headerlink" href="#raft-concepts" title="Permalink to this headline">¶</a></h3>
<p>While Raft offers many of the same features as Kafka — albeit in a simpler and
easier-to-use package — it functions substantially different under the covers
from Kafka and introduces a number of new concepts, or twists on existing
concepts, to Fabric.</p>
<p><strong>Log entry</strong>. The primary unit of work in a Raft ordering service is a “log
entry”, with the full sequence of such entries known as the “log”. We consider
the log consistent if a majority (a quorum, in other words) of members agree on
the entries and their order, making the logs on the various orderers replicated.</p>
<p><strong>Consenter set</strong>. The ordering nodes actively participating in the consensus
mechanism for a given channel and receiving replicated logs for the channel.
This can be all of the nodes available (either in a single cluster or in
multiple clusters contributing to the system channel), or a subset of those
nodes.</p>
<p><strong>Finite-State Machine (FSM)</strong>. Every ordering node in Raft has an FSM and
collectively they’re used to ensure that the sequence of logs in the various
ordering nodes is deterministic (written in the same sequence).</p>
<p><strong>Quorum</strong>. Describes the minimum number of consenters that need to affirm a
proposal so that transactions can be ordered. For every consenter set, this is a
<strong>majority</strong> of nodes. In a cluster with five nodes, three must be available for
there to be a quorum. If a quorum of nodes is unavailable for any reason, the
ordering service cluster becomes unavailable for both read and write operations
on the channel, and no new logs can be committed.</p>
<p><strong>Leader</strong>. This is not a new concept — Kafka also uses leaders, as we’ve said —
but it’s critical to understand that at any given time, a channel’s consenter set
elects a single node to be the leader (we’ll describe how this happens in Raft
later). The leader is responsible for ingesting new log entries, replicating
them to follower ordering nodes, and managing when an entry is considered
committed. This is not a special <strong>type</strong> of orderer. It is only a role that
an orderer may have at certain times, and then not others, as circumstances
determine.</p>
<p><strong>Follower</strong>. Again, not a new concept, but what’s critical to understand about
followers is that the followers receive the logs from the leader and
replicate them deterministically, ensuring that logs remain consistent. As
we’ll see in our section on leader election, the followers also receive
“heartbeat” messages from the leader. In the event that the leader stops
sending those message for a configurable amount of time, the followers will
initiate a leader election and one of them will be elected the new leader.</p>
</div>
<div class="section" id="raft-in-a-transaction-flow">
<h3>Raft in a transaction flow<a class="headerlink" href="#raft-in-a-transaction-flow" title="Permalink to this headline">¶</a></h3>
<p>Every channel runs on a <strong>separate</strong> instance of the Raft protocol, which allows
each instance to elect a different leader. This configuration also allows
further decentralization of the service in use cases where clusters are made up
of ordering nodes controlled by different organizations. While all Raft nodes
must be part of the system channel, they do not necessarily have to be part of
all application channels. Channel creators (and channel admins) have the ability
to pick a subset of the available orderers and to add or remove ordering nodes
as needed (as long as only a single node is added or removed at a time).</p>
<p>While this configuration creates more overhead in the form of redundant heartbeat
messages and goroutines, it lays necessary groundwork for BFT.</p>
<p>In Raft, transactions (in the form of proposals or configuration updates) are
automatically routed by the ordering node that receives the transaction to the
current leader of that channel. This means that peers and applications do not
need to know who the leader node is at any particular time. Only the ordering
nodes need to know.</p>
<p>When the orderer validation checks have been completed, the transactions are
ordered, packaged into blocks, consented on, and distributed, as described in
phase two of our transaction flow.</p>
</div>
<div class="section" id="architectural-notes">
<h3>Architectural notes<a class="headerlink" href="#architectural-notes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="how-leader-election-works-in-raft">
<h4>How leader election works in Raft<a class="headerlink" href="#how-leader-election-works-in-raft" title="Permalink to this headline">¶</a></h4>
<p>Although the process of electing a leader happens within the orderer’s internal
processes, it’s worth noting how the process works.</p>
<p>Raft nodes are always in one of three states: follower, candidate, or leader.
All nodes initially start out as a <strong>follower</strong>. In this state, they can accept
log entries from a leader (if one has been elected), or cast votes for leader.
If no log entries or heartbeats are received for a set amount of time (for
example, five seconds), nodes self-promote to the <strong>candidate</strong> state. In the
candidate state, nodes request votes from other nodes. If a candidate receives a
quorum of votes, then it is promoted to a <strong>leader</strong>. The leader must accept new
log entries and replicate them to the followers.</p>
<p>For a visual representation of how the leader election process works, check out
<a class="reference external" href="http://thesecretlivesofdata.com/raft/">The Secret Lives of Data</a>.</p>
</div>
<div class="section" id="snapshots">
<h4>Snapshots<a class="headerlink" href="#snapshots" title="Permalink to this headline">¶</a></h4>
<p>If an ordering node goes down, how does it get the logs it missed when it is
restarted?</p>
<p>While it’s possible to keep all logs indefinitely, in order to save disk space,
Raft uses a process called “snapshotting”, in which users can define how many
bytes of data will be kept in the log. This amount of data will conform to a
certain number of blocks (which depends on the amount of data in the blocks.
Note that only full blocks are stored in a snapshot).</p>
<p>For example, let’s say lagging replica <code class="docutils literal notranslate"><span class="pre">R1</span></code> was just reconnected to the network.
Its latest block is <code class="docutils literal notranslate"><span class="pre">100</span></code>. Leader <code class="docutils literal notranslate"><span class="pre">L</span></code> is at block <code class="docutils literal notranslate"><span class="pre">196</span></code>, and is configured to
snapshot at amount of data that in this case represents 20 blocks. <code class="docutils literal notranslate"><span class="pre">R1</span></code> would
therefore receive block <code class="docutils literal notranslate"><span class="pre">180</span></code> from <code class="docutils literal notranslate"><span class="pre">L</span></code> and then make a <code class="docutils literal notranslate"><span class="pre">Deliver</span></code> request for
blocks <code class="docutils literal notranslate"><span class="pre">101</span></code> to <code class="docutils literal notranslate"><span class="pre">180</span></code>. Blocks <code class="docutils literal notranslate"><span class="pre">180</span></code> to <code class="docutils literal notranslate"><span class="pre">196</span></code> would then be replicated to <code class="docutils literal notranslate"><span class="pre">R1</span></code>
through the normal Raft protocol.</p>
</div>
</div>
<div class="section" id="kafka">
<h3>Kafka<a class="headerlink" href="#kafka" title="Permalink to this headline">¶</a></h3>
<p>The other crash fault tolerant ordering service supported by Fabric is an
adaptation of a Kafka distributed streaming platform for use as a cluster of
ordering nodes. You can read more about Kafka at the <a class="reference external" href="https://kafka.apache.org/intro">Apache Kafka Web site</a>,
but at a high level, Kafka uses the same conceptual “leader and follower”
configuration used by Raft, in which transactions (which Kafka calls “messages”)
are replicated from the leader node to the follower nodes. In the event the
leader node goes down, one of the followers becomes the leader and ordering can
continue, ensuring fault tolerance, just as with Raft.</p>
<p>The management of the Kafka cluster, including the coordination of tasks,
cluster membership, access control, and controller election, among others, is
handled by a ZooKeeper ensemble and its related APIs.</p>
<p>Kafka clusters and ZooKeeper ensembles are notoriously tricky to set up, so our
documentation assumes a working knowledge of Kafka and ZooKeeper. If you decide
to use Kafka without having this expertise, you should complete, <em>at a minimum</em>,
the first six steps of the <a class="reference external" href="https://kafka.apache.org/quickstart">Kafka Quickstart guide</a> before experimenting with the
Kafka-based ordering service. You can also consult
<a class="reference external" href="https://github.com/hyperledger/fabric/blob/release-1.1/bddtests/dc-orderer-kafka.yml">this sample configuration file</a>
for a brief explanation of the sensible defaults for Kafka and ZooKeeper.</p>
<p>To learn how to bring up a a Kafka-based ordering service, check out <a class="reference external" href="../kafka.html">our documentation on Kafka</a>.</p>
<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/) --></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../private-data/private-data.html" class="btn btn-neutral float-right" title="Private data" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../ledger/ledger.html" class="btn btn-neutral" title="Ledger" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Hyperledger 2019.
    <br>
      <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>