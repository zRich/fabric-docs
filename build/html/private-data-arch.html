

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>私有数据 &mdash; hyperledger-fabricdocs master 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Read-Write set semantics" href="readwrite.html" />
    <link rel="prev" title="Peer channel-based event services" href="peer_event_services.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          


          
            <a href="index.html" class="icon icon-home"> hyperledger-fabricdocs
          

          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

<br><img style="background-color: #fff; height: unset; width: unset;" alt="Hyperledger Fabric" src=_images/hyperledger_fabric_logo_color.png />
<br>
<a href="https://github.com/hyperledger/fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="GitHub" src="_static/images/github_button.png"/></a>
&nbsp;<a href="https://stackoverflow.com/questions/tagged/hyperledger-fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="StackOverflow" src="_static/images/stackoverflow_button.png"/></a>
&nbsp;<a href="https://chat.hyperledger.org"><img style="padding: 0px; margin: auto auto auto auto;" alt="Rocket Chat" src="_static/images/rocketchat_button.png"/></a>
&nbsp;<a href="https://www.youtube.com/playlist?list=PL0MZ85B_96CH7wvtrRzV7SvtRY0sI0DEg"><img style="padding: 0px; margin: auto auto auto auto;" alt="Youtube Channel" src="_static/images/youtube_button.png"/></a>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whatis.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html">v2.0 Alpha 新功能</a></li>
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html#release-notes">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="developapps/developing_applications.html">开发应用程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="ops_guide.html">操作指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_ref.html">命令参考</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="architecture.html">架构参考</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="arch-deep-dive.html">架构起源</a></li>
<li class="toctree-l2"><a class="reference internal" href="txflow.html">Transaction Flow</a></li>
<li class="toctree-l2"><a class="reference external" href="http://hyperledger-fabric-ca.readthedocs.io/en/latest">Hyperledger Fabric CA's User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="fabric-sdks.html">Hyperledger Fabric SDKs</a></li>
<li class="toctree-l2"><a class="reference internal" href="discovery-overview.html">Service Discovery</a></li>
<li class="toctree-l2"><a class="reference internal" href="channels.html">通道</a></li>
<li class="toctree-l2"><a class="reference internal" href="capability_requirements.html">功能需求</a></li>
<li class="toctree-l2"><a class="reference internal" href="couchdb_as_state_database.html">CouchDB as the State Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="peer_event_services.html">Peer channel-based event services</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">私有数据</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#private-data-collection-definition">私有数据集合定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#private-data-dissemination">Private data dissemination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referencing-collections-from-chaincode">Referencing collections from chaincode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-to-pass-private-data-in-a-chaincode-proposal">How to pass private data in a chaincode proposal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-control-for-private-data">Access control for private data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#querying-private-data">Querying Private Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-indexes-with-collections">Using Indexes with collections</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#considerations-when-using-private-data">Considerations when using private data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#private-data-purging">Private data purging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#updating-a-collection-definition">Updating a collection definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#private-data-reconciliation">Private data reconciliation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="readwrite.html">Read-Write set semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="gossip.html">Gossip data dissemination protocol</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Fabric-FAQ.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="questions.html">Still Have Questions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="status.html">Status</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">hyperledger-fabricdocs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="architecture.html">架构参考</a> &raquo;</li>
        
      <li>私有数据</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/private-data-arch.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="private-data">
<h1>私有数据<a class="headerlink" href="#private-data" title="永久链接至标题">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本主题假设您已经理解`“关于私有数据的文档 &lt;private-data/private-data.html&gt;`_ 中的概念。</p>
</div>
<div class="section" id="private-data-collection-definition">
<h2>私有数据集合定义<a class="headerlink" href="#private-data-collection-definition" title="永久链接至标题">¶</a></h2>
<p>集合定义包含一个或多个集合，每个集合都有一个用来定义列出集合中的组织的策略，以及用于在背书时控制私有数据传播的属性，还有一个可选的操作，决定是否清除数据。</p>
<p>从Fabric v2.0 Alpha版引入的Fabric链码生命周期开始，集合定义是链码定义的一部分。集合由通道成员批准，然后当链码的定义被提交到通道时会部署集合。对所有通道成员来说，集合文件都是相同的。如果您使用节点CLI来批准和提交链码的定义，那么使用 <code class="docutils literal notranslate"><span class="pre">--collections-config</span></code> 参数来指定集合的定义文件所在的路径。如果您正在使用Node版的Fabric SDK，请访问 <a class="reference external" href="https://fabric-sdk-node.github.io/master/tutorial-chaincode-lifecycle.html">如何安装和启动链代码</a>。使用 <a class="reference external" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/chaincode4noah.html">previous lifecycle process</a> 来部署私有数据集合时，需要在 <a class="reference external" href="https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerchaincode.html#peer-chaincode-instantiate">实例化你的链码</a> 阶段使用 <code class="docutils literal notranslate"><span class="pre">--collections-config</span></code> 参数。</p>
<p>集合定义由以下属性组成:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: 集合名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">policy</span></code>:私有数据集合分发策略定义了哪些组织的peer被允许使用``Signature``策略语法表示持久化集合数据，每个成员都包含在`OR`` 签名策略列表中。为了支持读/写交易，私有数据分发策略必须定义比链码背书策略更广泛的组织集合，因为peer必须拥有私有数据才能背书提议的交易。例如，在一个有十个组织的通道中，五个组织可能包括在一个私有数据集合分发策略中，但是背书策略可能要求任意三个组织背书。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code>: 在背书节点签署背书并将提案响应返回给客户端之前，每个背书节点必须成功地向其传播私有数据的最小节点数量（跨授权组织）。要求先传播才能背书的条件将确保即使背书的节点变的无法使用了，也能从网络中获得私有数据。当``requiredPeerCount`` 为``0``时，意味着分布存储不是必须的**required**，但是如果``maxPeerCount``大于0，则可能存在一些分布存储。通常不建议将 <code class="docutils literal notranslate"><span class="pre">requiredPeerCount``设为``0</span></code>，因为如果背书节点变得不可用，则可能导致网络中的私有数据丢失。通常，您可能希望在背书时至少需要一些私有数据的分布存储，以确保网络中多个节点上的私有数据有冗余。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>:出于数据冗余的目的，每个背书节点尝试将私有数据分发给的其他节点（跨授权组织）的最大节点数量。如果在背书时间和提交时间之间某个背书节点不可用，那么在背书时间还没接收到私有数据到集合成员节点将能够从已接收到私有数据的节点中拉取私有数据。如果将此值设置为``0``，则不会在背书时传播私有数据，从而迫使已被授权获取私有数据的节点在提交时从背书节点拉取私有数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blockToLive</span></code>:这个属性表示以块的形式存储在私有数据库上的数据应该存在多长时间。数据将在私有数据库上保留本字段指定的数量的块，超出这个数量长度的将被清除，使该数据在网络中过期，目的是不能从链码查询它，从节点也请求不到。如果要无限期地保留私有数据，即永远不清除私有数据，请将 <code class="docutils literal notranslate"><span class="pre">blockToLive</span></code> 属性设置为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code>: 这个值为``true``表示节点自动强制要求只允许属于集合成员之一的组织的客户端对私有数据进行读访问。如果来自非成员组织的客户端试图执行一个链码函数，该函数执行对私有数据的读取功能，那么这个链码调用将以一个错误的形式终止。如果希望在每个链码函数中编码更细粒度的访问控制，请使用``false``值。</p></li>
</ul>
<p>下边是一个定义集合的例子的JSON 文件，包含一个数组，数组内容为两个集合的定义：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>
 <span class="o">{</span>
    <span class="s2">&quot;name&quot;</span>: <span class="s2">&quot;collectionMarbles&quot;</span>,
    <span class="s2">&quot;policy&quot;</span>: <span class="s2">&quot;OR(&#39;Org1MSP.member&#39;, &#39;Org2MSP.member&#39;)&quot;</span>,
    <span class="s2">&quot;requiredPeerCount&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;maxPeerCount&quot;</span>: <span class="m">3</span>,
    <span class="s2">&quot;blockToLive&quot;</span>:1000000,
    <span class="s2">&quot;memberOnlyRead&quot;</span>: <span class="nb">true</span>
 <span class="o">}</span>,
 <span class="o">{</span>
    <span class="s2">&quot;name&quot;</span>: <span class="s2">&quot;collectionMarblePrivateDetails&quot;</span>,
    <span class="s2">&quot;policy&quot;</span>: <span class="s2">&quot;OR(&#39;Org1MSP.member&#39;)&quot;</span>,
    <span class="s2">&quot;requiredPeerCount&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;maxPeerCount&quot;</span>: <span class="m">3</span>,
    <span class="s2">&quot;blockToLive&quot;</span>:3,
    <span class="s2">&quot;memberOnlyRead&quot;</span>: <span class="nb">true</span>
 <span class="o">}</span>
<span class="o">]</span>
</pre></div>
</div>
<p>This example uses the organizations from the BYFN sample network, <code class="docutils literal notranslate"><span class="pre">Org1</span></code> and
<code class="docutils literal notranslate"><span class="pre">Org2</span></code> . The policy in the  <code class="docutils literal notranslate"><span class="pre">collectionMarbles</span></code> definition authorizes both
organizations to the private data. This is a typical configuration when the
chaincode data needs to remain private from the ordering service nodes. However,
the policy in the <code class="docutils literal notranslate"><span class="pre">collectionMarblePrivateDetails</span></code> definition restricts access
to a subset of organizations in the channel (in this case <code class="docutils literal notranslate"><span class="pre">Org1</span></code> ). In a real
scenario, there would be many organizations in the channel, with two or more
organizations in each collection sharing private data between them.</p>
</div>
<div class="section" id="private-data-dissemination">
<h2>Private data dissemination<a class="headerlink" href="#private-data-dissemination" title="永久链接至标题">¶</a></h2>
<p>Since private data is not included in the transactions that get submitted to
the ordering service, and therefore not included in the blocks that get distributed
to all peers in a channel, the endorsing peer plays an important role in
disseminating private data to other peers of authorized organizations. This ensures
the availability of private data in the channel’s collection, even if endorsing
peers become unavailable after their endorsement. To assist with this dissemination,
the  <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> properties in the collection definition
control the degree of dissemination at endorsement time.</p>
<p>If the endorsing peer cannot successfully disseminate the private data to at least
the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code>, it will return an error back to the client. The endorsing
peer will attempt to disseminate the private data to peers of different organizations,
in an effort to ensure that each authorized organization has a copy of the private
data. Since transactions are not committed at chaincode execution time, the endorsing
peer and recipient peers store a copy of the private data in a local <code class="docutils literal notranslate"><span class="pre">transient</span> <span class="pre">store</span></code>
alongside their blockchain until the transaction is committed.</p>
<p>When authorized peers do not have a copy of the private data in their transient
data store at commit time (either because they were not an endorsing peer or because
they did not receive the private data via dissemination at endorsement time),
they will attempt to pull the private data from another authorized
peer, <em>for a configurable amount of time</em> based on the peer property
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.pullRetryThreshold</span></code> in the peer configuration <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code>
file.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The peers being asked for private data will only return the private data
if the requesting peer is a member of the collection as defined by the
private data dissemination policy.</p>
</div>
<p>Considerations when using <code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>:</p>
<ul class="simple">
<li><p>If the requesting peer is able to retrieve the private data within the
<code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>, it will commit the transaction to its ledger
(including the private data hash), and store the private data in its
state database, logically separated from other channel state data.</p></li>
<li><p>If the requesting peer is not able to retrieve the private data within
the <code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>, it will commit the transaction to it’s blockchain
(including the private data hash), without the private data.</p></li>
<li><p>If the peer was entitled to the private data but it is missing, then
that peer will not be able to endorse future transactions that reference
the missing private data - a chaincode query for a key that is missing will
be detected (based on the presence of the key’s hash in the state database),
and the chaincode will receive an error.</p></li>
</ul>
<p>Therefore, it is important to set the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>
properties large enough to ensure the availability of private data in your
channel. For example, if each of the endorsing peers become unavailable
before the transaction commits, the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>
properties will have ensured the private data is available on other peers.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>For collections to work, it is important to have cross organizational
gossip configured correctly. Refer to our documentation on <a class="reference internal" href="gossip.html"><span class="doc">Gossip data dissemination protocol</span></a>,
paying particular attention to the “anchor peers” and “external endpoint”
configuration.</p>
</div>
</div>
<div class="section" id="referencing-collections-from-chaincode">
<h2>Referencing collections from chaincode<a class="headerlink" href="#referencing-collections-from-chaincode" title="永久链接至标题">¶</a></h2>
<p>A set of <a class="reference external" href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim">shim APIs</a>
are available for setting and retrieving private data.</p>
<p>The same chaincode data operations can be applied to channel state data and
private data, but in the case of private data, a collection name is specified
along with the data in the chaincode APIs, for example
<code class="docutils literal notranslate"><span class="pre">PutPrivateData(collection,key,value)</span></code> and <code class="docutils literal notranslate"><span class="pre">GetPrivateData(collection,key)</span></code>.</p>
<p>A single chaincode can reference multiple collections.</p>
<div class="section" id="how-to-pass-private-data-in-a-chaincode-proposal">
<h3>How to pass private data in a chaincode proposal<a class="headerlink" href="#how-to-pass-private-data-in-a-chaincode-proposal" title="永久链接至标题">¶</a></h3>
<p>Since the chaincode proposal gets stored on the blockchain, it is also important
not to include private data in the main part of the chaincode proposal. A special
field in the chaincode proposal called the <code class="docutils literal notranslate"><span class="pre">transient</span></code> field can be used to pass
private data from the client (or data that chaincode will use to generate private
data), to chaincode invocation on the peer.  The chaincode can retrieve the
<code class="docutils literal notranslate"><span class="pre">transient</span></code> field by calling the <a class="reference external" href="https://github.com/hyperledger/fabric/blob/8b3cbda97e58d1a4ff664219244ffd1d89d7fba8/core/chaincode/shim/interfaces.go#L315-L321">GetTransient() API</a>.
This <code class="docutils literal notranslate"><span class="pre">transient</span></code> field gets excluded from the channel transaction.</p>
</div>
<div class="section" id="access-control-for-private-data">
<h3>Access control for private data<a class="headerlink" href="#access-control-for-private-data" title="永久链接至标题">¶</a></h3>
<p>Until version 1.3, access control to private data based on collection membership
was enforced for peers only. Access control based on the organization of the
chaincode proposal submitter was required to be encoded in chaincode logic.
Starting in v1.4 a collection configuration option <code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> can
automatically enforce access control based on the organization of the chaincode
proposal submitter. For more information about collection
configuration definitions and how to set them, refer back to the
<a class="reference internal" href="#private-data-collection-definition">Private data collection definition</a>  section of this topic.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>If you would like more granular access control, you can set
<code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> to false. You can then apply your own access
control logic in chaincode, for example by calling the GetCreator()
chaincode API or using the client identity
<a class="reference external" href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/shim/ext/cid">chaincode library</a> .</p>
</div>
</div>
<div class="section" id="querying-private-data">
<h3>Querying Private Data<a class="headerlink" href="#querying-private-data" title="永久链接至标题">¶</a></h3>
<p>Private data collection can be queried just like normal channel data, using
shim APIs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataByRange(collection,</span> <span class="pre">startKey,</span> <span class="pre">endKey</span> <span class="pre">string)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataByPartialCompositeKey(collection,</span> <span class="pre">objectType</span> <span class="pre">string,</span> <span class="pre">keys</span> <span class="pre">[]string)</span></code></p></li>
</ul>
<p>And for the CouchDB state database, JSON content queries can be passed using the
shim API:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataQueryResult(collection,</span> <span class="pre">query</span> <span class="pre">string)</span></code></p></li>
</ul>
<p>Limitations:</p>
<ul class="simple">
<li><p>Clients that call chaincode that executes range or rich JSON queries should be aware
that they may receive a subset of the result set, if the peer they query has missing
private data, based on the explanation in Private Data Dissemination section
above.  Clients can query multiple peers and compare the results to
determine if a peer may be missing some of the result set.</p></li>
<li><p>Chaincode that executes range or rich JSON queries and updates data in a single
transaction is not supported, as the query results cannot be validated on the peers
that don’t have access to the private data, or on peers that are missing the
private data that they have access to. If a chaincode invocation both queries
and updates private data, the proposal request will return an error. If your application
can tolerate result set changes between chaincode execution and validation/commit time,
then you could call one chaincode function to perform the query, and then call a second
chaincode function to make the updates. Note that calls to GetPrivateData() to retrieve
individual keys can be made in the same transaction as PutPrivateData() calls, since
all peers can validate key reads based on the hashed key version.</p></li>
</ul>
</div>
<div class="section" id="using-indexes-with-collections">
<h3>Using Indexes with collections<a class="headerlink" href="#using-indexes-with-collections" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The Fabric chaincode lifecycle being introduced in the Fabric v2.0
Alpha does not support using couchDB indexes with your chaincode. To use
the previous lifecycle model to deploy couchDB indexes with private data
collections, visit the v1.4 version of the <a class="reference external" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/private-data-arch.html">Private Data Architecture Guide</a>.</p>
</div>
<p>The topic <a class="reference internal" href="couchdb_as_state_database.html"><span class="doc">CouchDB as the State Database</span></a> describes indexes that can be
applied to the channel’s state database to enable JSON content queries, by
packaging indexes in a <code class="docutils literal notranslate"><span class="pre">META-INF/statedb/couchdb/indexes</span></code> directory at chaincode
installation time.  Similarly, indexes can also be applied to private data
collections, by packaging indexes in a <code class="docutils literal notranslate"><span class="pre">META-INF/statedb/couchdb/collections/&lt;collection_name&gt;/indexes</span></code>
directory. An example index is available <a class="reference external" href="https://github.com/hyperledger/fabric-samples/blob/master/chaincode/marbles02_private/go/META-INF/statedb/couchdb/collections/collectionMarbles/indexes/indexOwner.json">here</a>.</p>
</div>
</div>
<div class="section" id="considerations-when-using-private-data">
<h2>Considerations when using private data<a class="headerlink" href="#considerations-when-using-private-data" title="永久链接至标题">¶</a></h2>
<div class="section" id="private-data-purging">
<h3>Private data purging<a class="headerlink" href="#private-data-purging" title="永久链接至标题">¶</a></h3>
<p>Private data can be periodically purged from peers. For more details,
see the <code class="docutils literal notranslate"><span class="pre">blockToLive</span></code> collection definition property above.</p>
<p>Additionally, recall that prior to commit, peers store private data in a local
transient data store. This data automatically gets purged when the transaction
commits.  But if a transaction was never submitted to the channel and
therefore never committed, the private data would remain in each peer’s
transient store.  This data is purged from the transient store after a
configurable number blocks by using the peer’s
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.transientstoreMaxBlockRetention</span></code> property in the peer
<code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> file.</p>
</div>
<div class="section" id="updating-a-collection-definition">
<h3>Updating a collection definition<a class="headerlink" href="#updating-a-collection-definition" title="永久链接至标题">¶</a></h3>
<p>To update a collection definition or add a new collection, you can upgrade
the chaincode to a new version and pass the new collection configuration
in the chaincode upgrade transaction, for example using the <code class="docutils literal notranslate"><span class="pre">--collections-config</span></code>
flag if using the CLI. If a collection configuration is specified during the
chaincode upgrade, a definition for each of the existing collections must be
included.</p>
<p>When upgrading a chaincode, you can add new private data collections,
and update existing private data collections, for example to add new
members to an existing collection or change one of the collection definition
properties. Note that you cannot update the collection name or the
blockToLive property, since a consistent blockToLive is required
regardless of a peer’s block height.</p>
<p>Collection updates becomes effective when a peer commits the block that
contains the chaincode upgrade transaction. Note that collections cannot be
deleted, as there may be prior private data hashes on the channel’s blockchain
that cannot be removed.</p>
</div>
<div class="section" id="private-data-reconciliation">
<h3>Private data reconciliation<a class="headerlink" href="#private-data-reconciliation" title="永久链接至标题">¶</a></h3>
<p>Starting in v1.4, peers of organizations that are added to an existing collection
will automatically fetch private data that was committed to the collection before
they joined the collection.</p>
<p>This private data “reconciliation” also applies to peers that
were entitled to receive private data but did not yet receive it — because of
a network failure, for example — by keeping track of private data that was “missing”
at the time of block commit.</p>
<p>Private data reconciliation occurs periodically based on the
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.reconciliationEnabled</span></code> and <code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.reconcileSleepInterval</span></code>
properties in core.yaml. The peer will periodically attempt to fetch the private
data from other collection member peers that are expected to have it.</p>
<p>Note that this private data reconciliation feature only works on peers running
v1.4 or later of Fabric.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="readwrite.html" class="btn btn-neutral float-right" title="Read-Write set semantics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="peer_event_services.html" class="btn btn-neutral" title="Peer channel-based event services" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Hyperledger 2019.
    <br>
      <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>