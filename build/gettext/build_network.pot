# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-01 12:09+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/build_network.rst:2
msgid "Building Your First Network"
msgstr ""

#: ../../source/build_network.rst:4
msgid "These instructions have been verified to work against the latest stable Docker images and the pre-compiled setup utilities within the supplied tar file. If you run these commands with images or tools from the current master branch, it is possible that you will see configuration and panic errors."
msgstr ""

#: ../../source/build_network.rst:11
msgid "The build your first network (BYFN) scenario provisions a sample Hyperledger Fabric network consisting of two organizations, each maintaining two peer nodes. It also will deploy a \"Solo\" ordering service by default, though other ordering service implementations are available."
msgstr ""

#: ../../source/build_network.rst:17
msgid "Install prerequisites"
msgstr ""

#: ../../source/build_network.rst:19
msgid "Before we begin, if you haven't already done so, you may wish to check that you have all the :doc:`prereqs` installed on the platform(s) on which you'll be developing blockchain applications and/or operating Hyperledger Fabric."
msgstr ""

#: ../../source/build_network.rst:23
msgid "You will also need to :doc:`install`. You will notice that there are a number of samples included in the ``fabric-samples`` repository. We will be using the ``first-network`` sample. Let's open that sub-directory now."
msgstr ""

#: ../../source/build_network.rst:31
msgid "The supplied commands in this documentation **MUST** be run from your ``first-network`` sub-directory of the ``fabric-samples`` repository clone.  If you elect to run the commands from a different location, the various provided scripts will be unable to find the binaries."
msgstr ""

#: ../../source/build_network.rst:37
msgid "Want to run it now?"
msgstr ""

#: ../../source/build_network.rst:39
msgid "We provide a fully annotated script --- ``byfn.sh`` --- that leverages these Docker images to quickly bootstrap a Hyperledger Fabric network that by default is comprised of four peers representing two different organizations, and an orderer node. It will also launch a container to run a scripted execution that will join peers to a channel, deploy a chaincode and drive execution of transactions against the deployed chaincode."
msgstr ""

#: ../../source/build_network.rst:46
msgid "Here's the help text for the ``byfn.sh`` script:"
msgstr ""

#: ../../source/build_network.rst:84
msgid "If you choose not to supply a flag, the script will use default values."
msgstr ""

#: ../../source/build_network.rst:87
msgid "Generate Network Artifacts"
msgstr ""

#: ../../source/build_network.rst:89
msgid "Ready to give it a go? Okay then! Execute the following command:"
msgstr ""

#: ../../source/build_network.rst:95
msgid "You will see a brief description as to what will occur, along with a yes/no command line prompt. Respond with a ``y`` or hit the return key to execute the described action."
msgstr ""

#: ../../source/build_network.rst:143
msgid "This first step generates all of the certificates and keys for our various network entities, the ``genesis block`` used to bootstrap the ordering service, and a collection of configuration transactions required to configure a :ref:`Channel`."
msgstr ""

#: ../../source/build_network.rst:149
msgid "Bring Up the Network"
msgstr ""

#: ../../source/build_network.rst:151
msgid "Next, you can bring the network up with one of the following commands:"
msgstr ""

#: ../../source/build_network.rst:157
msgid "The above command will compile Golang chaincode images and spin up the corresponding containers. Go is the default chaincode language, however there is also support for `Node.js <https://fabric-shim.github.io/>`_ and `Java <https://fabric-chaincode-java.github.io/>`_ chaincode. If you'd like to run through this tutorial with node chaincode, pass the following command instead:"
msgstr ""

#: ../../source/build_network.rst:170
msgid "For more information on the Node.js shim, please refer to its `documentation <https://fabric-shim.github.io/ChaincodeInterface.html>`_."
msgstr ""

#: ../../source/build_network.rst:173
msgid "For more information on the Java shim, please refer to its `documentation <https://fabric-chaincode-java.github.io/org/hyperledger/fabric/shim/Chaincode.html>`_."
msgstr ""

#: ../../source/build_network.rst:176
msgid "Ð¢o make the sample run with Java chaincode, you have to specify ``-l java`` as follows:"
msgstr ""

#: ../../source/build_network.rst:182
msgid "Do not run both of these commands. Only one language can be tried unless you bring down and recreate the network between."
msgstr ""

#: ../../source/build_network.rst:185
msgid "In addition to support for multiple chaincode languages, you can also issue a flag that will bring up a five node Raft ordering service or a Kafka ordering service instead of the one node Solo orderer. For more information about the currently supported ordering service implementations, check out :doc:`orderer/ordering_service`."
msgstr ""

#: ../../source/build_network.rst:190
msgid "To bring up the network with a Raft ordering service, issue:"
msgstr ""

#: ../../source/build_network.rst:196
msgid "To bring up the network with a Kafka ordering service, issue:"
msgstr ""

#: ../../source/build_network.rst:202
msgid "Once again, you will be prompted as to whether you wish to continue or abort. Respond with a ``y`` or hit the return key:"
msgstr ""

#: ../../source/build_network.rst:228
msgid "The logs will continue from there. This will launch all of the containers, and then drive a complete end-to-end application scenario. Upon successful completion, it should report the following in your terminal window:"
msgstr ""

#: ../../source/build_network.rst:247
msgid "You can scroll through these logs to see the various transactions. If you don't get this result, then jump down to the :ref:`Troubleshoot` section and let's see whether we can help you discover what went wrong."
msgstr ""

#: ../../source/build_network.rst:252
msgid "Bring Down the Network"
msgstr ""

#: ../../source/build_network.rst:254
msgid "Finally, let's bring it all down so we can explore the network setup one step at a time. The following will kill your containers, remove the crypto material and four artifacts, and delete the chaincode images from your Docker Registry:"
msgstr ""

#: ../../source/build_network.rst:262
msgid "Once again, you will be prompted to continue, respond with a ``y`` or hit the return key:"
msgstr ""

#: ../../source/build_network.rst:278
msgid "If you'd like to learn more about the underlying tooling and bootstrap mechanics, continue reading.  In these next sections we'll walk through the various steps and requirements to build a fully-functional Hyperledger Fabric network."
msgstr ""

#: ../../source/build_network.rst:282
msgid "The manual steps outlined below assume that the ``FABRIC_LOGGING_SPEC`` in the ``cli`` container is set to ``DEBUG``. You can set this by modifying the ``docker-compose-cli.yaml`` file in the ``first-network`` directory. e.g."
msgstr ""

#: ../../source/build_network.rst:301
msgid "Crypto Generator"
msgstr ""

#: ../../source/build_network.rst:303
msgid "We will use the ``cryptogen`` tool to generate the cryptographic material (x509 certs and signing keys) for our various network entities.  These certificates are representative of identities, and they allow for sign/verify authentication to take place as our entities communicate and transact."
msgstr ""

#: ../../source/build_network.rst:309
#: ../../source/build_network.rst:353
msgid "How does it work?"
msgstr ""

#: ../../source/build_network.rst:311
msgid "Cryptogen consumes a file --- ``crypto-config.yaml`` --- that contains the network topology and allows us to generate a set of certificates and keys for both the Organizations and the components that belong to those Organizations.  Each Organization is provisioned a unique root certificate (``ca-cert``) that binds specific components (peers and orderers) to that Org.  By assigning each Organization a unique CA certificate, we are mimicking a typical network where a participating :ref:`Member` would use its own Certificate Authority. Transactions and communications within Hyperledger Fabric are signed by an entity's private key (``keystore``), and then verified by means of a public key (``signcerts``)."
msgstr ""

#: ../../source/build_network.rst:322
msgid "You will notice a ``count`` variable within this file. We use this to specify the number of peers per Organization; in our case there are two peers per Org. We won't delve into the minutiae of `x.509 certificates and public key infrastructure <https://en.wikipedia.org/wiki/Public_key_infrastructure>`_ right now. If you're interested, you can peruse these topics on your own time."
msgstr ""

#: ../../source/build_network.rst:328
msgid "After we run the ``cryptogen`` tool, the generated certificates and keys will be saved to a folder titled ``crypto-config``. Note that the ``crypto-config.yaml`` file lists five orderers as being tied to the orderer organization. While the ``cryptogen`` tool will create certificates for all five of these orderers, unless the Raft or Kafka ordering services are being used, only one of these orderers will be used in a Solo ordering service implementation and be used to create the system channel and ``mychannel``."
msgstr ""

#: ../../source/build_network.rst:337
msgid "Configuration Transaction Generator"
msgstr ""

#: ../../source/build_network.rst:339
msgid "The ``configtxgen`` tool is used to create four configuration artifacts:"
msgstr ""

#: ../../source/build_network.rst:341
msgid "orderer ``genesis block``,"
msgstr ""

#: ../../source/build_network.rst:342
msgid "channel ``configuration transaction``,"
msgstr ""

#: ../../source/build_network.rst:343
msgid "and two ``anchor peer transactions`` - one for each Peer Org."
msgstr ""

#: ../../source/build_network.rst:345
msgid "Please see :doc:`commands/configtxgen` for a complete description of this tool's functionality."
msgstr ""

#: ../../source/build_network.rst:347
msgid "The orderer block is the :ref:`Genesis-Block` for the ordering service, and the channel configuration transaction file is broadcast to the orderer at :ref:`Channel` creation time.  The anchor peer transactions, as the name might suggest, specify each Org's :ref:`Anchor-Peer` on this channel."
msgstr ""

#: ../../source/build_network.rst:355
msgid "Configtxgen consumes a file - ``configtx.yaml`` - that contains the definitions for the sample network. There are three members - one Orderer Org (``OrdererOrg``) and two Peer Orgs (``Org1`` & ``Org2``) each managing and maintaining two peer nodes. This file also specifies a consortium - ``SampleConsortium`` - consisting of our two Peer Orgs.  Pay specific attention to the \"Profiles\" section at the bottom of this file. You will notice that we have several unique profiles. A few are worth noting:"
msgstr ""

#: ../../source/build_network.rst:363
msgid "``TwoOrgsOrdererGenesis``: generates the genesis block for a Solo ordering service."
msgstr ""

#: ../../source/build_network.rst:366
msgid "``SampleMultiNodeEtcdRaft``: generates the genesis block for a Raft ordering service. Only used if you issue the ``-o`` flag and specify ``etcdraft``."
msgstr ""

#: ../../source/build_network.rst:369
msgid "``SampleDevModeKafka``: generates the genesis block for a Kafka ordering service. Only used if you issue the ``-o`` flag and specify ``kafka``."
msgstr ""

#: ../../source/build_network.rst:372
msgid "``TwoOrgsChannel``: generates the genesis block for our channel, ``mychannel``."
msgstr ""

#: ../../source/build_network.rst:374
msgid "These headers are important, as we will pass them in as arguments when we create our artifacts."
msgstr ""

#: ../../source/build_network.rst:377
msgid "Notice that our ``SampleConsortium`` is defined in the system-level profile and then referenced by our channel-level profile.  Channels exist within the purview of a consortium, and all consortia must be defined in the scope of the network at large."
msgstr ""

#: ../../source/build_network.rst:384
msgid "This file also contains two additional specifications that are worth noting. Firstly, we specify the anchor peers for each Peer Org (``peer0.org1.example.com`` & ``peer0.org2.example.com``).  Secondly, we point to the location of the MSP directory for each member, in turn allowing us to store the root certificates for each Org in the orderer genesis block.  This is a critical concept. Now any network entity communicating with the ordering service can have its digital signature verified."
msgstr ""

#: ../../source/build_network.rst:393
msgid "Run the tools"
msgstr ""

#: ../../source/build_network.rst:395
msgid "You can manually generate the certificates/keys and the various configuration artifacts using the ``configtxgen`` and ``cryptogen`` commands. Alternately, you could try to adapt the byfn.sh script to accomplish your objectives."
msgstr ""

#: ../../source/build_network.rst:400
msgid "Manually generate the artifacts"
msgstr ""

#: ../../source/build_network.rst:402
msgid "You can refer to the ``generateCerts`` function in the byfn.sh script for the commands necessary to generate the certificates that will be used for your network configuration as defined in the ``crypto-config.yaml`` file. However, for the sake of convenience, we will also provide a reference here."
msgstr ""

#: ../../source/build_network.rst:407
msgid "First let's run the ``cryptogen`` tool.  Our binary is in the ``bin`` directory, so we need to provide the relative path to where the tool resides."
msgstr ""

#: ../../source/build_network.rst:414
msgid "You should see the following in your terminal:"
msgstr ""

#: ../../source/build_network.rst:421
msgid "The certs and keys (i.e. the MSP material) will be output into a directory - ``crypto-config`` - at the root of the ``first-network`` directory."
msgstr ""

#: ../../source/build_network.rst:424
msgid "Next, we need to tell the ``configtxgen`` tool where to look for the ``configtx.yaml`` file that it needs to ingest.  We will tell it look in our present working directory:"
msgstr ""

#: ../../source/build_network.rst:432
msgid "Then, we'll invoke the ``configtxgen`` tool to create the orderer genesis block:"
msgstr ""

#: ../../source/build_network.rst:438
msgid "To output a genesis block for a Raft ordering service, this command should be:"
msgstr ""

#: ../../source/build_network.rst:444
msgid "Note the ``SampleMultiNodeEtcdRaft`` profile being used here."
msgstr ""

#: ../../source/build_network.rst:446
msgid "To output a genesis block for a Kafka ordering service, issue:"
msgstr ""

#: ../../source/build_network.rst:452
msgid "If you are not using Raft or Kafka, you should see an output similar to the following:"
msgstr ""

#: ../../source/build_network.rst:461
msgid "The orderer genesis block and the subsequent artifacts we are about to create will be output into the ``channel-artifacts`` directory at the root of this project. The `channelID` in the above command is the name of the system channel."
msgstr ""

#: ../../source/build_network.rst:468
msgid "Create a Channel Configuration Transaction"
msgstr ""

#: ../../source/build_network.rst:470
msgid "Next, we need to create the channel transaction artifact. Be sure to replace ``$CHANNEL_NAME`` or set ``CHANNEL_NAME`` as an environment variable that can be used throughout these instructions:"
msgstr ""

#: ../../source/build_network.rst:479
msgid "Note that you don't have to issue a special command for the channel if you are using a Raft or Kafka ordering service. The ``TwoOrgsChannel`` profile will use the ordering service configuration you specified when creating the genesis block for the network."
msgstr ""

#: ../../source/build_network.rst:484
msgid "If you are not using a Raft or Kafka ordering service, you should see an output similar to the following in your terminal:"
msgstr ""

#: ../../source/build_network.rst:493
msgid "Next, we will define the anchor peer for Org1 on the channel that we are constructing. Again, be sure to replace ``$CHANNEL_NAME`` or set the environment variable for the following commands.  The terminal output will mimic that of the channel transaction artifact:"
msgstr ""

#: ../../source/build_network.rst:502
msgid "Now, we will define the anchor peer for Org2 on the same channel:"
msgstr ""

#: ../../source/build_network.rst:509
msgid "Start the network"
msgstr ""

#: ../../source/build_network.rst:511
msgid "If you ran the ``byfn.sh`` example above previously, be sure that you have brought down the test network before you proceed (see `Bring Down the Network`_)."
msgstr ""

#: ../../source/build_network.rst:515
msgid "We will leverage a script to spin up our network. The docker-compose file references the images that we have previously downloaded, and bootstraps the orderer with our previously generated ``genesis.block``."
msgstr ""

#: ../../source/build_network.rst:519
msgid "We want to go through the commands manually in order to expose the syntax and functionality of each call."
msgstr ""

#: ../../source/build_network.rst:522
msgid "First let's start our network:"
msgstr ""

#: ../../source/build_network.rst:528
msgid "If you want to see the realtime logs for your network, then do not supply the ``-d`` flag. If you let the logs stream, then you will need to open a second terminal to execute the CLI calls."
msgstr ""

#: ../../source/build_network.rst:534
msgid "Create & Join Channel"
msgstr ""

#: ../../source/build_network.rst:536
msgid "Recall that we created the channel configuration transaction using the ``configtxgen`` tool in the :ref:`createchanneltx` section, above. You can repeat that process to create additional channel configuration transactions, using the same or different profiles in the ``configtx.yaml`` that you pass to the ``configtxgen`` tool. Then you can repeat the process defined in this section to establish those other channels in your network."
msgstr ""

#: ../../source/build_network.rst:543
msgid "We will enter the CLI container using the ``docker exec`` command:"
msgstr ""

#: ../../source/build_network.rst:549
msgid "If successful you should see the following:"
msgstr ""

#: ../../source/build_network.rst:555
msgid "For the following CLI commands against ``peer0.org1.example.com`` to work, we need to preface our commands with the four environment variables given below.  These variables for ``peer0.org1.example.com`` are baked into the CLI container, therefore we can operate without passing them. **HOWEVER**, if you want to send calls to other peers or the orderer, keep the CLI container defaults targeting ``peer0.org1.example.com``, but override the environment variables as seen in the example below when you make any CLI calls:"
msgstr ""

#: ../../source/build_network.rst:572
msgid "Next, we are going to pass in the generated channel configuration transaction artifact that we created in the :ref:`createchanneltx` section (we called it ``channel.tx``) to the orderer as part of the create channel request."
msgstr ""

#: ../../source/build_network.rst:576
msgid "We specify our channel name with the ``-c`` flag and our channel configuration transaction with the ``-f`` flag. In this case it is ``channel.tx``, however you can mount your own configuration transaction with a different name.  Once again we will set the ``CHANNEL_NAME`` environment variable within our CLI container so that we don't have to explicitly pass this argument. Channel names must be all lower case, less than 250 characters long and match the regular expression ``[a-z][a-z0-9.-]*``."
msgstr ""

#: ../../source/build_network.rst:595
msgid "Notice the ``--cafile`` that we pass as part of this command.  It is the local path to the orderer's root cert, allowing us to verify the TLS handshake."
msgstr ""

#: ../../source/build_network.rst:599
msgid "This command returns a genesis block - ``<CHANNEL_NAME.block>`` - which we will use to join the channel. It contains the configuration information specified in ``channel.tx``  If you have not made any modifications to the default channel name, then the command will return you a proto titled ``mychannel.block``."
msgstr ""

#: ../../source/build_network.rst:604
msgid "You will remain in the CLI container for the remainder of these manual commands. You must also remember to preface all commands with the corresponding environment variables when targeting a peer other than ``peer0.org1.example.com``."
msgstr ""

#: ../../source/build_network.rst:609
msgid "Now let's join ``peer0.org1.example.com`` to the channel."
msgstr ""

#: ../../source/build_network.rst:620
msgid "You can make other peers join the channel as necessary by making appropriate changes in the four environment variables we used in the :ref:`peerenvvars` section, above."
msgstr ""

#: ../../source/build_network.rst:624
msgid "Rather than join every peer, we will simply join ``peer0.org2.example.com`` so that we can properly update the anchor peer definitions in our channel.  Since we are overriding the default environment variables baked into the CLI container, this full command will be the following:"
msgstr ""

#: ../../source/build_network.rst:633
msgid "Alternatively, you could choose to set these environment variables individually rather than passing in the entire string.  Once they've been set, you simply need to issue the ``peer channel join`` command again and the CLI container will act on behalf of ``peer0.org2.example.com``."
msgstr ""

#: ../../source/build_network.rst:639
msgid "Update the anchor peers"
msgstr ""

#: ../../source/build_network.rst:641
msgid "The following commands are channel updates and they will propagate to the definition of the channel.  In essence, we adding additional configuration information on top of the channel's genesis block.  Note that we are not modifying the genesis block, but simply adding deltas into the chain that will define the anchor peers."
msgstr ""

#: ../../source/build_network.rst:646
msgid "Update the channel definition to define the anchor peer for Org1 as ``peer0.org1.example.com``:"
msgstr ""

#: ../../source/build_network.rst:652
msgid "Now update the channel definition to define the anchor peer for Org2 as ``peer0.org2.example.com``. Identically to the ``peer channel join`` command for the Org2 peer, we will need to preface this call with the appropriate environment variables."
msgstr ""

#: ../../source/build_network.rst:663
msgid "Install and define a chaincode"
msgstr ""

#: ../../source/build_network.rst:665
msgid "We will utilize a simple existing chaincode. To learn how to write your own chaincode, see the :doc:`chaincode4ade` tutorial."
msgstr ""

#: ../../source/build_network.rst:668
msgid "These instructions use the Fabric chaincode lifecycle introduced in the v2.0 Alpha release. If you would like to use the previous lifecycle to install and instantiate a chaincode, visit the v1.4 version of the `Building your first network tutorial <https://hyperledger-fabric.readthedocs.io/en/release-1.4/build_network.html>`__."
msgstr ""

#: ../../source/build_network.rst:673
msgid "Applications interact with the blockchain ledger through ``chaincode``. Therefore we need to install a chaincode on every peer that will execute and endorse our transactions. However, before we can interact with our chaincode, the members of the channel need to agree on a chaincode definition that establishes chaincode governance."
msgstr ""

#: ../../source/build_network.rst:679
msgid "We need to package the chaincode before it can be installed on our peers. For each package you create, you need to provide a chaincode package label as a description of the chaincode. Use the following commands to package a sample Go, Node.js or Java chaincode."
msgstr ""

#: ../../source/build_network.rst:684
msgid "**Golang**"
msgstr ""

#: ../../source/build_network.rst:694
msgid "**Node.js**"
msgstr ""

#: ../../source/build_network.rst:704
msgid "**Java**"
msgstr ""

#: ../../source/build_network.rst:714
msgid "Each of the above commands will create a chaincode package named ``mycc.tar.gz`, which we can use to install the chaincode on our peers. Issue the following command to install the package on peer0 of Org1."
msgstr ""

#: ../../source/build_network.rst:723
msgid "A successful install command will return a chaincode package identifier. You should see output similar to the following:"
msgstr ""

#: ../../source/build_network.rst:731
msgid "You can also find the chaincode package identifier by querying your peer for information about the packages you have installed."
msgstr ""

#: ../../source/build_network.rst:739
msgid "The command above will return the same package identifier as the install command. You should see output similar to the following:"
msgstr ""

#: ../../source/build_network.rst:747
msgid "We are going to need the package ID for future commands, so let's go ahead and save it as an environment variable. Paste the package ID returned by the `peer lifecycle chaincode queryinstalled` command into the command below. The package ID may not be the same for all users, so you need to complete this step using the package ID returned from your console."
msgstr ""

#: ../../source/build_network.rst:759
msgid "The endorsement policy of ``mycc`` will be set to require endorsements from a peer in both Org1 and Org2. Therefore, we also need to install the chaincode on a peer in Org2."
msgstr ""

#: ../../source/build_network.rst:763
msgid "Modify the following four environment variables to issue the install command as Org2:"
msgstr ""

#: ../../source/build_network.rst:775
msgid "Now install the chaincode package onto peer0 of Org2. The following command will install the chaincode and return same identifier as the install command we issued as Org1."
msgstr ""

#: ../../source/build_network.rst:784
msgid "After you install the package, you need to approve a chaincode definition for your organization. The chaincode definition includes the important parameters of chaincode governance, including the chaincode name and version. The definition also includes the package identifier used to associate the chaincode package installed on your peers with a chaincode definition approved by your organization."
msgstr ""

#: ../../source/build_network.rst:791
msgid "Because we set the environment variables to operate as Org2, we can use the following command to approve a definition of the ``mycc`` chaincode for Org2. The approval is distributed within each organization using gossip, so the command does not need to target every peer within an organization."
msgstr ""

#: ../../source/build_network.rst:803
msgid "We could have provided a ``--signature-policy`` or ``--channel-config-policy`` argument to the command above to set the chaincode endorsement policy. The endorsement policy specifies how many peers belonging to different channel members need to validate a transaction against a given chaincode. Because we did not set a policy, the definition of ``mycc`` will use the default endorsement policy, which requires that a transaction be endorsed by a majority of channel members present when the transaction is submitted. This implies that if new organizations are added to or removed from the channel, the endorsement policy is updated automatically to require more or fewer endorsements. In this tutorial, the default policy will require an endorsement from a peer belonging to Org1 **AND** Org2 (i.e. two endorsements). See the :doc:`endorsement-policies` documentation for more details on policy implementation."
msgstr ""

#: ../../source/build_network.rst:816
msgid "All organizations need to agree on the definition before they can use the chaincode. Modify the following four environment variables to operate as Org1:"
msgstr ""

#: ../../source/build_network.rst:828
msgid "You can now approve a definition for the ``mycc`` chaincode as Org1. Chaincode is approved at the organization level. You can issue the command once even if you have multiple peers."
msgstr ""

#: ../../source/build_network.rst:839
msgid "Once a sufficient number of channel members have approved a chaincode definition, one member can commit the definition to the channel. By default a majority of channel members need to approve a definition before it can be committed. It is possible to discover the approval status for the chanincode definition across all organizations by issuing the following query:"
msgstr ""

#: ../../source/build_network.rst:852
msgid "The command will produce as output a JSON map showing if the organizations in the channel have approved the chaincode definition provided in the queryapprovalstatus command. In this case, given that both organizations have approved, we obtain:"
msgstr ""

#: ../../source/build_network.rst:865
msgid "Since both channel members have approved the definition, we can now commit it to the channel using the following command. You can issue this command as either Org1 or Org2. Note that the transaction targets peers in Org1 and Org2 to collect endorsements."
msgstr ""

#: ../../source/build_network.rst:876
msgid "Invoking the chaincode"
msgstr ""

#: ../../source/build_network.rst:878
msgid "After a chaincode definition has been committed to a channel, we are ready to invoke the chaincode and start interacting with the ledger. We requested the execution of the ``Init`` function in the chaincode definition using the ``--init-required`` flag. As a result, we need to pass the ``--isInit`` flag to its first invocation and supply the arguments to the ``Init`` function. Issue the following command to initialize the chaincode and put the initial data on the ledger."
msgstr ""

#: ../../source/build_network.rst:892
msgid "The first invoke will start the chaincode container. We may need to wait for the container to start. Node.js images will take longer."
msgstr ""

#: ../../source/build_network.rst:896
#: ../../source/build_network.rst:919
#: ../../source/build_network.rst:969
msgid "Query"
msgstr ""

#: ../../source/build_network.rst:898
msgid "Let's query the chaincode to make sure that the container was properly started and the state DB was populated. The syntax for query is as follows:"
msgstr ""

#: ../../source/build_network.rst:908
msgid "Invoke"
msgstr ""

#: ../../source/build_network.rst:910
msgid "Now letâs move ``10`` from ``a`` to ``b``. This transaction will cut a new block and update the state DB. The syntax for invoke is as follows:"
msgstr ""

#: ../../source/build_network.rst:921
msgid "Let's confirm that our previous invocation executed properly. We initialized the key ``a`` with a value of ``100`` and just removed ``10`` with our previous invocation. Therefore, a query against ``a`` should return ``90``. The syntax for query is as follows."
msgstr ""

#: ../../source/build_network.rst:932
#: ../../source/build_network.rst:991
msgid "We should see the following:"
msgstr ""

#: ../../source/build_network.rst:939
msgid "Install the chaincode on an additional peer"
msgstr ""

#: ../../source/build_network.rst:941
msgid "If you want additional peers to interact with the ledger, then you will need to join them to the channel and install the same chaincode package on the peers. You only need to approve the chaincode definition once from your organization. A chaincode container will be launched for each peer as soon as they try to interact with that specific chaincode. Again, be cognizant of the fact that the Node.js images will be slower to build and start upon the first invoke."
msgstr ""

#: ../../source/build_network.rst:948
msgid "We will install the chaincode on a third peer, peer1 in Org2. Modify the following four environment variables to issue the install command against peer1 in Org2:"
msgstr ""

#: ../../source/build_network.rst:961
msgid "Now install the ``mycc`` package on peer1 of Org2:"
msgstr ""

#: ../../source/build_network.rst:971
msgid "Let's confirm that we can issue the query to Peer1 in Org2. We initialized the key ``a`` with a value of ``100`` and just removed ``10`` with our previous invocation. Therefore, a query against ``a`` should still return ``90``."
msgstr ""

#: ../../source/build_network.rst:975
msgid "Peer1 in Org2 must first join the channel before it can respond to queries. The channel can be joined by issuing the following command:"
msgstr ""

#: ../../source/build_network.rst:982
msgid "After the join command returns, the query can be issued. The syntax for query is as follows."
msgstr ""

#: ../../source/build_network.rst:997
msgid "If you received an error, it may be because it takes a few seconds for the peer to join and catch up to the current blockchain height. You may re-query as needed. Feel free to perform additional invokes as well."
msgstr ""

#: ../../source/build_network.rst:1004
msgid "What's happening behind the scenes?"
msgstr ""

#: ../../source/build_network.rst:1006
msgid "These steps describe the scenario in which ``script.sh`` is run by './byfn.sh up'.  Clean your network with ``./byfn.sh down`` and ensure this command is active.  Then use the same docker-compose prompt to launch your network again"
msgstr ""

#: ../../source/build_network.rst:1012
msgid "A script - ``script.sh`` - is baked inside the CLI container. The script drives the ``createChannel`` command against the supplied channel name and uses the channel.tx file for channel configuration."
msgstr ""

#: ../../source/build_network.rst:1016
msgid "The output of ``createChannel`` is a genesis block - ``<your_channel_name>.block`` - which gets stored on the peers' file systems and contains the channel configuration specified from channel.tx."
msgstr ""

#: ../../source/build_network.rst:1020
msgid "The ``joinChannel`` command is exercised for all four peers, which takes as input the previously generated genesis block.  This command instructs the peers to join ``<your_channel_name>`` and create a chain starting with ``<your_channel_name>.block``."
msgstr ""

#: ../../source/build_network.rst:1024
msgid "Now we have a channel consisting of four peers, and two organizations.  This is our ``TwoOrgsChannel`` profile."
msgstr ""

#: ../../source/build_network.rst:1027
msgid "``peer0.org1.example.com`` and ``peer1.org1.example.com`` belong to Org1; ``peer0.org2.example.com`` and ``peer1.org2.example.com`` belong to Org2"
msgstr ""

#: ../../source/build_network.rst:1030
msgid "These relationships are defined through the ``crypto-config.yaml`` and the MSP path is specified in our docker compose."
msgstr ""

#: ../../source/build_network.rst:1033
msgid "The anchor peers for Org1MSP (``peer0.org1.example.com``) and Org2MSP (``peer0.org2.example.com``) are then updated.  We do this by passing the ``Org1MSPanchors.tx`` and ``Org2MSPanchors.tx`` artifacts to the ordering service along with the name of our channel."
msgstr ""

#: ../../source/build_network.rst:1038
msgid "A chaincode - **abstore** - is packaged and installed on ``peer0.org1.example.com`` and ``peer0.org2.example.com``"
msgstr ""

#: ../../source/build_network.rst:1041
msgid "The chaincode is then separately approved by Org1 and Org2, and then committed on the channel. Since an endorsement policy was not specified, the channel's default endorsement policy of a majority of organizations will get utilized, meaning that any transaction must be endorsed by a peer tied to Org1 and Org2."
msgstr ""

#: ../../source/build_network.rst:1046
msgid "The chaincode Init is then called which starts the container for the target peer, and initializes the key value pairs associated with the chaincode.  The initial values for this example are [\"a\",\"100\" \"b\",\"200\"]. This first invoke results in a container by the name of ``dev-peer0.org2.example.com-mycc-1.0`` starting."
msgstr ""

#: ../../source/build_network.rst:1051
msgid "A query against the value of \"a\" is issued to ``peer0.org2.example.com``. A container for Org2 peer0 by the name of ``dev-peer0.org2.example.com-mycc-1.0`` was started when the chaincode was initialized. The result of the query is returned. No write operations have occurred, so a query against \"a\" will still return a value of \"100\"."
msgstr ""

#: ../../source/build_network.rst:1057
msgid "An invoke is sent to ``peer0.org1.example.com`` and ``peer0.org2.example.com`` to move \"10\" from \"a\" to \"b\""
msgstr ""

#: ../../source/build_network.rst:1060
msgid "A query is sent to ``peer0.org2.example.com`` for the value of \"a\". A value of 90 is returned, correctly reflecting the previous transaction during which the value for key \"a\" was modified by 10."
msgstr ""

#: ../../source/build_network.rst:1064
msgid "The chaincode - **abstore** - is installed on ``peer1.org2.example.com``"
msgstr ""

#: ../../source/build_network.rst:1066
msgid "A query is sent to ``peer1.org2.example.com`` for the value of \"a\". This starts a third chaincode container by the name of ``dev-peer1.org2.example.com-mycc-1.0``. A value of 90 is returned, correctly reflecting the previous transaction during which the value for key \"a\" was modified by 10."
msgstr ""

#: ../../source/build_network.rst:1072
msgid "What does this demonstrate?"
msgstr ""

#: ../../source/build_network.rst:1074
msgid "Chaincode **MUST** be installed on a peer in order for it to successfully perform read/write operations against the ledger. Furthermore, a chaincode container is not started for a peer until an ``init`` or traditional transaction - read/write - is performed against that chaincode (e.g. query for the value of \"a\"). The transaction causes the container to start. Also, all peers in a channel maintain an exact copy of the ledger which comprises the blockchain to store the immutable, sequenced record in blocks, as well as a state database to maintain a snapshot of the current state. This includes those peers that do not have chaincode installed on them (like ``peer1.org1.example.com`` in the above example) . Finally, the chaincode is accessible after it is installed (like ``peer1.org2.example.com`` in the above example) because its definition has already been committed on the channel."
msgstr ""

#: ../../source/build_network.rst:1088
msgid "How do I see these transactions?"
msgstr ""

#: ../../source/build_network.rst:1090
msgid "Check the logs for the CLI Docker container."
msgstr ""

#: ../../source/build_network.rst:1096
msgid "You should see the following output:"
msgstr ""

#: ../../source/build_network.rst:1117
msgid "You can scroll through these logs to see the various transactions."
msgstr ""

#: ../../source/build_network.rst:1120
msgid "How can I see the chaincode logs?"
msgstr ""

#: ../../source/build_network.rst:1122
msgid "Inspect the individual chaincode containers to see the separate transactions executed against each container. Here is the combined output from each container:"
msgstr ""

#: ../../source/build_network.rst:1145
msgid "You can also see the peer logs to view chaincode invoke messages and block commit messages:"
msgstr ""

#: ../../source/build_network.rst:1153
msgid "Understanding the Docker Compose topology"
msgstr ""

#: ../../source/build_network.rst:1155
msgid "The BYFN sample offers us two flavors of Docker Compose files, both of which are extended from the ``docker-compose-base.yaml`` (located in the ``base`` folder).  Our first flavor, ``docker-compose-cli.yaml``, provides us with a CLI container, along with an orderer, four peers.  We use this file for the entirety of the instructions on this page."
msgstr ""

#: ../../source/build_network.rst:1161
msgid "the remainder of this section covers a docker-compose file designed for the SDK.  Refer to the `Node SDK <https://github.com/hyperledger/fabric-sdk-node>`__ repo for details on running these tests."
msgstr ""

#: ../../source/build_network.rst:1165
msgid "The second flavor, ``docker-compose-e2e.yaml``, is constructed to run end-to-end tests using the Node.js SDK.  Aside from functioning with the SDK, its primary differentiation is that there are containers for the fabric-ca servers.  As a result, we are able to send REST calls to the organizational CAs for user registration and enrollment."
msgstr ""

#: ../../source/build_network.rst:1170
msgid "If you want to use the ``docker-compose-e2e.yaml`` without first running the byfn.sh script, then we will need to make four slight modifications. We need to point to the private keys for our Organization's CA's.  You can locate these values in your crypto-config folder.  For example, to locate the private key for Org1 we would follow this path - ``crypto-config/peerOrganizations/org1.example.com/ca/``. The private key is a long hash value followed by ``_sk``.  The path for Org2 would be - ``crypto-config/peerOrganizations/org2.example.com/ca/``."
msgstr ""

#: ../../source/build_network.rst:1178
msgid "In the ``docker-compose-e2e.yaml`` update the FABRIC_CA_SERVER_TLS_KEYFILE variable for ca0 and ca1.  You also need to edit the path that is provided in the command to start the ca server.  You are providing the same private key twice for each CA container."
msgstr ""

#: ../../source/build_network.rst:1184
msgid "Using CouchDB"
msgstr ""

#: ../../source/build_network.rst:1186
msgid "The state database can be switched from the default (goleveldb) to CouchDB. The same chaincode functions are available with CouchDB, however, there is the added ability to perform rich and complex queries against the state database data content contingent upon the chaincode data being modeled as JSON."
msgstr ""

#: ../../source/build_network.rst:1191
msgid "To use CouchDB instead of the default database (goleveldb), follow the same procedures outlined earlier for generating the artifacts, except when starting the network pass ``docker-compose-couch.yaml`` as well:"
msgstr ""

#: ../../source/build_network.rst:1199
msgid "**abstore** should now work using CouchDB underneath."
msgstr ""

#: ../../source/build_network.rst:1201
msgid "If you choose to implement mapping of the fabric-couchdb container port to a host port, please make sure you are aware of the security implications. Mapping of the port in a development environment makes the CouchDB REST API available, and allows the visualization of the database via the CouchDB web interface (Fauxton). Production environments would likely refrain from implementing port mapping in order to restrict outside access to the CouchDB containers."
msgstr ""

#: ../../source/build_network.rst:1209
msgid "You can use **abstore** chaincode against the CouchDB state database using the steps outlined above, however in order to exercise the CouchDB query capabilities you will need to use a chaincode that has data modeled as JSON. The sample chaincode **marbles02** has been written to demostrate the queries you can issue from your chaincode if you are using a CouchDB database. You can locate the **marbles02** chaincode in the ``fabric/examples/chaincode/go`` directory."
msgstr ""

#: ../../source/build_network.rst:1217
msgid "We will follow the same process to create and join the channel as outlined in the :ref:`peerenvvars` section above.  Once you have joined your peer(s) to the channel, use the following steps to interact with the **marbles02** chaincode:"
msgstr ""

#: ../../source/build_network.rst:1222
msgid "Package and install the chaincode on ``peer0.org1.example.com``:"
msgstr ""

#: ../../source/build_network.rst:1237
msgid "Save the packageID as an environment variable so you can pass it to future commands:"
msgstr ""

#: ../../source/build_network.rst:1244
msgid "Approve a chaincode definition as Org1:"
msgstr ""

#: ../../source/build_network.rst:1252
msgid "Install the chaincode on ``peer0.org2.example.com``:"
msgstr ""

#: ../../source/build_network.rst:1262
msgid "Approve a chaincode definition as Org2, and then commit the definition to the channel:"
msgstr ""

#: ../../source/build_network.rst:1272
msgid "We can now create some marbles. The first invoke of the chaincode will start the chaincode container. You may need to wait for the container to start."
msgstr ""

#: ../../source/build_network.rst:1281
msgid "Once the container has started, you can issue additional commands to create some marbles and move them around:"
msgstr ""

#: ../../source/build_network.rst:1294
msgid "If you chose to map the CouchDB ports in docker-compose, you can now view the state database through the CouchDB web interface (Fauxton) by opening a browser and navigating to the following URL:"
msgstr ""

#: ../../source/build_network.rst:1298
msgid "``http://localhost:5984/_utils``"
msgstr ""

#: ../../source/build_network.rst:1300
msgid "You should see a database named ``mychannel`` (or your unique channel name) and the documents inside it."
msgstr ""

#: ../../source/build_network.rst:1303
msgid "For the below commands, be sure to update the $CHANNEL_NAME variable appropriately."
msgstr ""

#: ../../source/build_network.rst:1305
msgid "You can run regular queries from the CLI (e.g. reading ``marble2``):"
msgstr ""

#: ../../source/build_network.rst:1311
msgid "The output should display the details of ``marble2``:"
msgstr ""

#: ../../source/build_network.rst:1317
msgid "You can retrieve the history of a specific marble - e.g. ``marble1``:"
msgstr ""

#: ../../source/build_network.rst:1323
msgid "The output should display the transactions on ``marble1``:"
msgstr ""

#: ../../source/build_network.rst:1329
msgid "You can also perform rich queries on the data content, such as querying marble fields by owner ``jerry``:"
msgstr ""

#: ../../source/build_network.rst:1335
msgid "The output should display the two marbles owned by ``jerry``:"
msgstr ""

#: ../../source/build_network.rst:1343
msgid "Why CouchDB"
msgstr ""

#: ../../source/build_network.rst:1344
msgid "CouchDB is a kind of NoSQL solution. It is a document-oriented database where document fields are stored as key-value maps. Fields can be either a simple key-value pair, list, or map. In addition to keyed/composite-key/key-range queries which are supported by LevelDB, CouchDB also supports full data rich queries capability, such as non-key queries against the whole blockchain data, since its data content is stored in JSON format and fully queryable. Therefore, CouchDB can meet chaincode, auditing, reporting requirements for many use cases that not supported by LevelDB."
msgstr ""

#: ../../source/build_network.rst:1348
msgid "CouchDB can also enhance the security for compliance and data protection in the blockchain. As it is able to implement field-level security through the filtering and masking of individual attributes within a transaction, and only authorizing the read-only permission if needed."
msgstr ""

#: ../../source/build_network.rst:1350
msgid "In addition, CouchDB falls into the AP-type (Availability and Partition Tolerance) of the CAP theorem. It uses a master-master replication model with ``Eventual Consistency``. More information can be found on the `Eventual Consistency page of the CouchDB documentation <http://docs.couchdb.org/en/latest/intro/consistency.html>`__. However, under each fabric peer, there is no database replicas, writes to database are guaranteed consistent and durable (not ``Eventual Consistency``)."
msgstr ""

#: ../../source/build_network.rst:1355
msgid "CouchDB is the first external pluggable state database for Fabric, and there could and should be other external database options. For example, IBM enables the relational database for its blockchain. And the CP-type (Consistency and Partition Tolerance) databases may also in need, so as to enable data consistency without application level guarantee."
msgstr ""

#: ../../source/build_network.rst:1360
msgid "A Note on Data Persistence"
msgstr ""

#: ../../source/build_network.rst:1362
msgid "If data persistence is desired on the peer container or the CouchDB container, one option is to mount a directory in the docker-host into a relevant directory in the container. For example, you may add the following two lines in the peer container specification in the ``docker-compose-base.yaml`` file:"
msgstr ""

#: ../../source/build_network.rst:1372
msgid "For the CouchDB container, you may add the following two lines in the CouchDB container specification:"
msgstr ""

#: ../../source/build_network.rst:1383
msgid "Troubleshooting"
msgstr ""

#: ../../source/build_network.rst:1385
msgid "Always start your network fresh.  Use the following command to remove artifacts, crypto, containers and chaincode images:"
msgstr ""

#: ../../source/build_network.rst:1392
msgid "You **will** see errors if you do not remove old containers and images."
msgstr ""

#: ../../source/build_network.rst:1395
msgid "If you see Docker errors, first check your docker version (:doc:`prereqs`), and then try restarting your Docker process.  Problems with Docker are oftentimes not immediately recognizable.  For example, you may see errors resulting from an inability to access crypto material mounted within a container."
msgstr ""

#: ../../source/build_network.rst:1401
msgid "If they persist remove your images and start from scratch:"
msgstr ""

#: ../../source/build_network.rst:1408
msgid "If you see errors on your create, approve, commit, invoke or query commands, make sure you have properly updated the channel name and chaincode name. There are placeholder values in the supplied sample commands."
msgstr ""

#: ../../source/build_network.rst:1412
#: ../../source/build_network.rst:1436
msgid "If you see the below error:"
msgstr ""

#: ../../source/build_network.rst:1418
msgid "You likely have chaincode images (e.g. ``dev-peer1.org2.example.com-mycc-1.0`` or ``dev-peer0.org1.example.com-mycc-1.0``) from prior runs. Remove them and try again."
msgstr ""

#: ../../source/build_network.rst:1426
msgid "If you see something similar to the following:"
msgstr ""

#: ../../source/build_network.rst:1433
msgid "Make sure you are running your network against the \"1.0.0\" images that have been retagged as \"latest\"."
msgstr ""

#: ../../source/build_network.rst:1443
msgid "Then you did not set the ``FABRIC_CFG_PATH`` environment variable properly.  The configtxgen tool needs this variable in order to locate the configtx.yaml.  Go back and execute an ``export FABRIC_CFG_PATH=$PWD``, then recreate your channel artifacts."
msgstr ""

#: ../../source/build_network.rst:1448
msgid "To cleanup the network, use the ``down`` option:"
msgstr ""

#: ../../source/build_network.rst:1454
msgid "If you see an error stating that you still have \"active endpoints\", then prune your Docker networks.  This will wipe your previous networks and start you with a fresh environment:"
msgstr ""

#: ../../source/build_network.rst:1462
msgid "You will see the following message:"
msgstr ""

#: ../../source/build_network.rst:1469
msgid "Select ``y``."
msgstr ""

#: ../../source/build_network.rst:1471
msgid "If you see an error similar to the following:"
msgstr ""

#: ../../source/build_network.rst:1477
msgid "Ensure that the file in question (**script.sh** in this example) is encoded in the Unix format. This was most likely caused by not setting ``core.autocrlf`` to ``false`` in your Git configuration (see :ref:`windows-extras`). There are several ways of fixing this. If you have access to the vim editor for instance, open the file:"
msgstr ""

#: ../../source/build_network.rst:1487
msgid "Then change its format by executing the following vim command:"
msgstr ""

#: ../../source/build_network.rst:1493
msgid "If you continue to see errors, share your logs on the **fabric-questions** channel on `Hyperledger Rocket Chat <https://chat.hyperledger.org/home>`__ or on `StackOverflow <https://stackoverflow.com/questions/tagged/hyperledger-fabric>`__."
msgstr ""

