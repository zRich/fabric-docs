# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-23 09:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/channel_update_tutorial.rst:2
msgid "Adding an Org to a Channel"
msgstr ""

#: ../../source/channel_update_tutorial.rst:4
msgid "Ensure that you have downloaded the appropriate images and binaries as outlined in :doc:`install` and :doc:`prereqs` that conform to the version of this documentation (which can be found at the bottom of the table of contents to the left). In particular, your version of the ``fabric-samples`` folder must include the ``eyfn.sh`` (\"Extending Your First Network\") script and its related scripts."
msgstr ""

#: ../../source/channel_update_tutorial.rst:11
msgid "This tutorial serves as an extension to the :doc:`build_network` (BYFN) tutorial, and will demonstrate the addition of a new organization -- ``Org3`` -- to the application channel (``mychannel``) autogenerated by BYFN. It assumes a strong understanding of BYFN, including the usage and functionality of the aforementioned utilities."
msgstr ""

#: ../../source/channel_update_tutorial.rst:17
msgid "While we will focus solely on the integration of a new organization here, the same approach can be adopted when performing other channel configuration updates (updating modification policies or altering batch size, for example). To learn more about the process and possibilities of channel config updates in general, check out :doc:`config_update`). It's also worth noting that channel configuration updates like the one demonstrated here will usually be the responsibility of an organization admin (rather than a chaincode or application developer)."
msgstr ""

#: ../../source/channel_update_tutorial.rst:25
msgid "Make sure the automated ``byfn.sh`` script runs without error on your machine before continuing. If you have exported your binaries and the related tools (``cryptogen``, ``configtxgen``, etc) into your PATH variable, you'll be able to modify the commands accordingly without passing the fully qualified path."
msgstr ""

#: ../../source/channel_update_tutorial.rst:32
msgid "Setup the Environment"
msgstr ""

#: ../../source/channel_update_tutorial.rst:34
msgid "We will be operating from the root of the ``first-network`` subdirectory within your local clone of ``fabric-samples``. Change into that directory now. You will also want to open a few extra terminals for ease of use."
msgstr ""

#: ../../source/channel_update_tutorial.rst:38
msgid "First, use the ``byfn.sh`` script to tidy up. This command will kill any active or stale docker containers and remove previously generated artifacts. It is by no means **necessary** to bring down a Fabric network in order to perform channel configuration update tasks. However, for the sake of this tutorial, we want to operate from a known initial state. Therefore let's run the following command to clean up any previous environments:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:49
msgid "Now generate the default BYFN artifacts:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:55
msgid "And launch the network making use of the scripted execution within the CLI container:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:61
msgid "Now that you have a clean version of BYFN running on your machine, you have two different paths you can pursue. First, we offer a fully commented script that will carry out a config transaction update to bring Org3 into the network."
msgstr ""

#: ../../source/channel_update_tutorial.rst:65
msgid "Also, we will show a \"manual\" version of the same process, showing each step and explaining what it accomplishes (since we show you how to bring down your network before this manual process, you could also run the script and then look at each step)."
msgstr ""

#: ../../source/channel_update_tutorial.rst:71
msgid "Bring Org3 into the Channel with the Script"
msgstr ""

#: ../../source/channel_update_tutorial.rst:73
msgid "You should be in ``first-network``. To use the script, simply issue the following:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:79
msgid "The output here is well worth reading. You'll see the Org3 crypto material being added, the config update being created and signed, and then chaincode being installed to allow Org3 to execute ledger queries."
msgstr ""

#: ../../source/channel_update_tutorial.rst:83
msgid "If everything goes well, you'll get this message:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:89
msgid "``eyfn.sh`` can be used with the same Node.js chaincode and database options as ``byfn.sh`` by issuing the following (instead of ``./byfn.sh up``):"
msgstr ""

#: ../../source/channel_update_tutorial.rst:96
msgid "And then:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:102
msgid "For those who want to take a closer look at this process, the rest of the doc will show you each command for making a channel update and what it does."
msgstr ""

#: ../../source/channel_update_tutorial.rst:106
msgid "Bring Org3 into the Channel Manually"
msgstr ""

#: ../../source/channel_update_tutorial.rst:108
msgid "The manual steps outlined below assume that the ``FABRIC_LOGGING_SPEC`` in the ``cli`` and ``Org3cli`` containers is set to ``DEBUG``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:111
msgid "For the ``cli`` container, you can set this by modifying the ``docker-compose-cli.yaml`` file in the ``first-network`` directory. e.g."
msgstr ""

#: ../../source/channel_update_tutorial.rst:128
msgid "For the ``Org3cli`` container, you can set this by modifying the ``docker-compose-org3.yaml`` file in the ``first-network`` directory. e.g."
msgstr ""

#: ../../source/channel_update_tutorial.rst:145
msgid "If you've used the ``eyfn.sh`` script, you'll need to bring your network down. This can be done by issuing:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:152
msgid "This will bring down the network, delete all the containers and undo what we've done to add Org3."
msgstr ""

#: ../../source/channel_update_tutorial.rst:155
msgid "When the network is down, bring it back up again."
msgstr ""

#: ../../source/channel_update_tutorial.rst:161
msgid "Then:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:167
msgid "This will bring your network back to the same state it was in before you executed the ``eyfn.sh`` script."
msgstr ""

#: ../../source/channel_update_tutorial.rst:170
msgid "Now we're ready to add Org3 manually. As a first step, we'll need to generate Org3's crypto material."
msgstr ""

#: ../../source/channel_update_tutorial.rst:174
msgid "Generate the Org3 Crypto Material"
msgstr ""

#: ../../source/channel_update_tutorial.rst:176
msgid "In another terminal, change into the ``org3-artifacts`` subdirectory from ``first-network``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:183
msgid "There are two ``yaml`` files of interest here: ``org3-crypto.yaml`` and ``configtx.yaml``. First, generate the crypto material for Org3:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:190
msgid "This command reads in our new crypto ``yaml`` file -- ``org3-crypto.yaml`` -- and leverages ``cryptogen`` to generate the keys and certificates for an Org3 CA as well as two peers bound to this new Org. As with the BYFN implementation, this crypto material is put into a newly generated ``crypto-config`` folder within the present working directory (in our case, ``org3-artifacts``)."
msgstr ""

#: ../../source/channel_update_tutorial.rst:196
msgid "Now use the ``configtxgen`` utility to print out the Org3-specific configuration material in JSON. We will preface the command by telling the tool to look in the current directory for the ``configtx.yaml`` file that it needs to ingest."
msgstr ""

#: ../../source/channel_update_tutorial.rst:204
msgid "The above command creates a JSON file -- ``org3.json`` -- and outputs it into the ``channel-artifacts`` subdirectory at the root of ``first-network``. This file contains the policy definitions for Org3, as well as three important certificates presented in base 64 format: the admin user certificate (which will be needed to act as the admin of Org3 later on), a CA root cert, and a TLS root cert. In an upcoming step we will append this JSON file to the channel configuration."
msgstr ""

#: ../../source/channel_update_tutorial.rst:211
msgid "Our final piece of housekeeping is to port the Orderer Org's MSP material into the Org3 ``crypto-config`` directory. In particular, we are concerned with the Orderer's TLS root cert, which will allow for secure communication between Org3 entities and the network's ordering node."
msgstr ""

#: ../../source/channel_update_tutorial.rst:220
msgid "Now we're ready to update the channel configuration..."
msgstr ""

#: ../../source/channel_update_tutorial.rst:223
msgid "Prepare the CLI Environment"
msgstr ""

#: ../../source/channel_update_tutorial.rst:225
msgid "The update process makes use of the configuration translator tool -- ``configtxlator``. This tool provides a stateless REST API independent of the SDK. Additionally it provides a CLI, to simplify configuration tasks in Fabric networks. The tool allows for the easy conversion between different equivalent data representations/formats (in this case, between protobufs and JSON). Additionally, the tool can compute a configuration update transaction based on the differences between two channel configurations."
msgstr ""

#: ../../source/channel_update_tutorial.rst:233
msgid "First, exec into the CLI container. Recall that this container has been mounted with the BYFN ``crypto-config`` library, giving us access to the MSP material for the two original peer organizations and the Orderer Org. The bootstrapped identity is the Org1 admin user, meaning that any steps where we want to act as Org2 will require the export of MSP-specific environment variables."
msgstr ""

#: ../../source/channel_update_tutorial.rst:243
msgid "Export the ``ORDERER_CA`` and ``CHANNEL_NAME`` variables:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:249
#: ../../source/channel_update_tutorial.rst:560
msgid "Check to make sure the variables have been properly set:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:255
msgid "If for any reason you need to restart the CLI container, you will also need to re-export the two environment variables -- ``ORDERER_CA`` and ``CHANNEL_NAME``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:259
msgid "Fetch the Configuration"
msgstr ""

#: ../../source/channel_update_tutorial.rst:261
msgid "Now we have a CLI container with our two key environment variables -- ``ORDERER_CA`` and ``CHANNEL_NAME`` exported.  Let's go fetch the most recent config block for the channel -- ``mychannel``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:265
msgid "The reason why we have to pull the latest version of the config is because channel config elements are versioned. Versioning is important for several reasons. It prevents config changes from being repeated or replayed (for instance, reverting to a channel config with old CRLs would represent a security risk). Also it helps ensure concurrency (if you want to remove an Org from your channel, for example, after a new Org has been added, versioning will help prevent you from removing both Orgs, instead of just the Org you want to remove)."
msgstr ""

#: ../../source/channel_update_tutorial.rst:277
msgid "This command saves the binary protobuf channel configuration block to ``config_block.pb``. Note that the choice of name and file extension is arbitrary. However, following a convention which identifies both the type of object being represented and its encoding (protobuf or JSON) is recommended."
msgstr ""

#: ../../source/channel_update_tutorial.rst:282
msgid "When you issued the ``peer channel fetch`` command, there was a decent amount of output in the terminal. The last line in the logs is of interest:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:289
msgid "This is telling us that the most recent configuration block for ``mychannel`` is actually block 2, **NOT** the genesis block. By default, the ``peer channel fetch config`` command returns the most **recent** configuration block for the targeted channel, which in this case is the third block. This is because the BYFN script defined anchor peers for our two organizations -- ``Org1`` and ``Org2`` -- in two separate channel update transactions."
msgstr ""

#: ../../source/channel_update_tutorial.rst:296
msgid "As a result, we have the following configuration sequence:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:298
msgid "block 0: genesis block"
msgstr ""

#: ../../source/channel_update_tutorial.rst:299
msgid "block 1: Org1 anchor peer update"
msgstr ""

#: ../../source/channel_update_tutorial.rst:300
msgid "block 2: Org2 anchor peer update"
msgstr ""

#: ../../source/channel_update_tutorial.rst:303
msgid "Convert the Configuration to JSON and Trim It Down"
msgstr ""

#: ../../source/channel_update_tutorial.rst:305
msgid "Now we will make use of the ``configtxlator`` tool to decode this channel configuration block into JSON format (which can be read and modified by humans). We also must strip away all of the headers, metadata, creator signatures, and so on that are irrelevant to the change we want to make. We accomplish this by means of the ``jq`` tool:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:315
msgid "This leaves us with a trimmed down JSON object -- ``config.json``, located in the ``fabric-samples`` folder inside ``first-network`` -- which will serve as the baseline for our config update."
msgstr ""

#: ../../source/channel_update_tutorial.rst:319
msgid "Take a moment to open this file inside your text editor of choice (or in your browser). Even after you're done with this tutorial, it will be worth studying it as it reveals the underlying configuration structure and the other kind of channel updates that can be made. We discuss them in more detail in :doc:`config_update`."
msgstr ""

#: ../../source/channel_update_tutorial.rst:325
msgid "Add the Org3 Crypto Material"
msgstr ""

#: ../../source/channel_update_tutorial.rst:327
msgid "The steps you've taken up to this point will be nearly identical no matter what kind of config update you're trying to make. We've chosen to add an org with this tutorial because it's one of the most complex channel configuration updates you can attempt."
msgstr ""

#: ../../source/channel_update_tutorial.rst:332
msgid "We'll use the ``jq`` tool once more to append the Org3 configuration definition -- ``org3.json`` -- to the channel's application groups field, and name the output -- ``modified_config.json``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:340
msgid "Now, within the CLI container we have two JSON files of interest -- ``config.json`` and ``modified_config.json``. The initial file contains only Org1 and Org2 material, whereas \"modified\" file contains all three Orgs. At this point it's simply a matter of re-encoding these two JSON files and calculating the delta."
msgstr ""

#: ../../source/channel_update_tutorial.rst:345
msgid "First, translate ``config.json`` back into a protobuf called ``config.pb``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:351
msgid "Next, encode ``modified_config.json`` to ``modified_config.pb``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:357
msgid "Now use ``configtxlator`` to calculate the delta between these two config protobufs. This command will output a new protobuf binary named ``org3_update.pb``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:364
msgid "This new proto -- ``org3_update.pb`` -- contains the Org3 definitions and high level pointers to the Org1 and Org2 material. We are able to forgo the extensive MSP material and modification policy information for Org1 and Org2 because this data is already present within the channel's genesis block. As such, we only need the delta between the two configurations."
msgstr ""

#: ../../source/channel_update_tutorial.rst:370
msgid "Before submitting the channel update, we need to perform a few final steps. First, let's decode this object into editable JSON format and call it ``org3_update.json``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:377
msgid "Now, we have a decoded update file -- ``org3_update.json`` -- that we need to wrap in an envelope message. This step will give us back the header field that we stripped away earlier. We'll name this file ``org3_update_in_envelope.json``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:385
msgid "Using our properly formed JSON -- ``org3_update_in_envelope.json`` -- we will leverage the ``configtxlator`` tool one last time and convert it into the fully fledged protobuf format that Fabric requires. We'll name our final update object ``org3_update_in_envelope.pb``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:395
msgid "Sign and Submit the Config Update"
msgstr ""

#: ../../source/channel_update_tutorial.rst:397
msgid "Almost done!"
msgstr ""

#: ../../source/channel_update_tutorial.rst:399
msgid "We now have a protobuf binary -- ``org3_update_in_envelope.pb`` -- within our CLI container. However, we need signatures from the requisite Admin users before the config can be written to the ledger. The modification policy (mod_policy) for our channel Application group is set to the default of \"MAJORITY\", which means that we need a majority of existing org admins to sign it. Because we have only two orgs -- Org1 and Org2 -- and the majority of two is two, we need both of them to sign. Without both signatures, the ordering service will reject the transaction for failing to fulfill the policy."
msgstr ""

#: ../../source/channel_update_tutorial.rst:408
msgid "First, let's sign this update proto as the Org1 Admin. Remember that the CLI container is bootstrapped with the Org1 MSP material, so we simply need to issue the ``peer channel signconfigtx`` command:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:416
msgid "The final step is to switch the CLI container's identity to reflect the Org2 Admin user. We do this by exporting four environment variables specific to the Org2 MSP."
msgstr ""

#: ../../source/channel_update_tutorial.rst:419
msgid "Switching between organizations to sign a config transaction (or to do anything else) is not reflective of a real-world Fabric operation. A single container would never be mounted with an entire network's crypto material. Rather, the config update would need to be securely passed out-of-band to an Org2 Admin for inspection and approval."
msgstr ""

#: ../../source/channel_update_tutorial.rst:425
msgid "Export the Org2 environment variables:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:439
msgid "Lastly, we will issue the ``peer channel update`` command. The Org2 Admin signature will be attached to this call so there is no need to manually sign the protobuf a second time:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:443
msgid "The upcoming update call to the ordering service will undergo a series of systematic signature and policy checks. As such you may find it useful to stream and inspect the ordering node's logs. From another shell, issue a ``docker logs -f orderer.example.com`` command to display them."
msgstr ""

#: ../../source/channel_update_tutorial.rst:448
msgid "Send the update call:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:454
msgid "You should see a message digest indication similar to the following if your update has been submitted successfully:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:461
msgid "You will also see the submission of our configuration transaction:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:467
msgid "The successful channel update call returns a new block -- block 5 -- to all of the peers on the channel. If you remember, blocks 0-2 are the initial channel configurations while blocks 3 and 4 are the instantiation and invocation of the ``mycc`` chaincode. As such, block 5 serves as the most recent channel configuration with Org3 now defined on the channel."
msgstr ""

#: ../../source/channel_update_tutorial.rst:473
msgid "Inspect the logs for ``peer0.org1.example.com``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:479
msgid "Follow the demonstrated process to fetch and decode the new config block if you wish to inspect its contents."
msgstr ""

#: ../../source/channel_update_tutorial.rst:483
msgid "Configuring Leader Election"
msgstr ""

#: ../../source/channel_update_tutorial.rst:485
msgid "This section is included as a general reference for understanding the leader election settings when adding organizations to a network after the initial channel configuration has completed. This sample defaults to dynamic leader election, which is set for all peers in the network in `peer-base.yaml`."
msgstr ""

#: ../../source/channel_update_tutorial.rst:491
msgid "Newly joining peers are bootstrapped with the genesis block, which does not contain information about the organization that is being added in the channel configuration update. Therefore new peers are not able to utilize gossip as they cannot verify blocks forwarded by other peers from their own organization until they get the configuration transaction which added the organization to the channel. Newly added peers must therefore have one of the following configurations so that they receive blocks from the ordering service:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:499
msgid "1. To utilize static leader mode, configure the peer to be an organization leader:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:508
msgid "This configuration must be the same for all new peers added to the channel."
msgstr ""

#: ../../source/channel_update_tutorial.rst:511
msgid "2. To utilize dynamic leader election, configure the peer to use leader election:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:520
msgid "Because peers of the newly added organization won't be able to form membership view, this option will be similar to the static configuration, as each peer will start proclaiming itself to be a leader. However, once they get updated with the configuration transaction that adds the organization to the channel, there will be only one active leader for the organization. Therefore, it is recommended to leverage this option if you eventually want the organization's peers to utilize leader election."
msgstr ""

#: ../../source/channel_update_tutorial.rst:531
msgid "Join Org3 to the Channel"
msgstr ""

#: ../../source/channel_update_tutorial.rst:533
msgid "At this point, the channel configuration has been updated to include our new organization -- ``Org3`` -- meaning that peers attached to it can now join ``mychannel``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:536
msgid "First, let's launch the containers for the Org3 peers and an Org3-specific CLI."
msgstr ""

#: ../../source/channel_update_tutorial.rst:538
msgid "Open a new terminal and from ``first-network`` kick off the Org3 docker compose:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:544
msgid "This new compose file has been configured to bridge across our initial network, so the two peers and the CLI container will be able to resolve with the existing peers and ordering node. With the three new containers now running, exec into the Org3-specific CLI container:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:553
msgid "Just as we did with the initial CLI container, export the two key environment variables: ``ORDERER_CA`` and ``CHANNEL_NAME``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:566
msgid "Now let's send a call to the ordering service asking for the genesis block of ``mychannel``. The ordering service is able to verify the Org3 signature attached to this call as a result of our successful channel update. If Org3 has not been successfully appended to the channel config, the ordering service should reject this request."
msgstr ""

#: ../../source/channel_update_tutorial.rst:572
msgid "Again, you may find it useful to stream the ordering node's logs to reveal the sign/verify logic and policy checks."
msgstr ""

#: ../../source/channel_update_tutorial.rst:575
msgid "Use the ``peer channel fetch`` command to retrieve this block:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:581
msgid "Notice, that we are passing a ``0`` to indicate that we want the first block on the channel's ledger (i.e. the genesis block). If we simply passed the ``peer channel fetch config`` command, then we would have received block 5 -- the updated config with Org3 defined. However, we can't begin our ledger with a downstream block -- we must start with block 0."
msgstr ""

#: ../../source/channel_update_tutorial.rst:587
msgid "Issue the ``peer channel join`` command and pass in the genesis block -- ``mychannel.block``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:593
msgid "If you want to join the second peer for Org3, export the ``TLS`` and ``ADDRESS`` variables and reissue the ``peer channel join command``:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:605
msgid "Install, define, and invoke chaincode"
msgstr ""

#: ../../source/channel_update_tutorial.rst:607
msgid "Once you have joined the channel, you can package and install a chaincode on a peer of Org3. You then need to approve the chaincode definition as org3. Because the chaincode definition has already been committed to the channel you have joined, you can start using the chaincode after you approve the definition."
msgstr ""

#: ../../source/channel_update_tutorial.rst:613
msgid "These instructions use the Fabric chaincode lifecycle introduced in the v2.0 Alpha release. If you would like to use the previous lifecycle to install and instantiate a chaincode, visit the v1.4 version of the `Adding an org to a channel tutorial <https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html>`__."
msgstr ""

#: ../../source/channel_update_tutorial.rst:618
msgid "The first step is to package the chaincode from the Org3 CLI:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:624
msgid "This command will create a chaincode package named ``mycc.tar.gz``, which we can use to install the chaincode on our peer. In this command, you need to provide a chaincode package label as a description of the chaincode. Modify the command accordingly if the channel is running a chaincode written in Java or Node.js. Issue the following command to install the package on peer0 of Org3:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:635
msgid "You can also modify the environment variables and reissue the command if you want to install the chaincode on the second peer of Org3. Note that a second installation is not mandated, as you only need to install chaincode on peers that are going to serve as endorsers or otherwise interface with the ledger (i.e. query only). Peers will still run the validation logic and serve as committers without a running chaincode container."
msgstr ""

#: ../../source/channel_update_tutorial.rst:642
msgid "The next step is to approve the chaincode definition of ``mycc`` as Org3. Org3 needs to approve the same definition that Org1 and Org2 approved and committed to the channel. The chaincode definition also needs to include the chaincode package identifier. You can find the package identifier by querying your peer:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:652
msgid "You should see output similar to the following:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:659
msgid "We are going to need the package ID in a future command, so lets go ahead and save it as an environment variable. Paste the package ID returned by the `peer lifecycle chaincode queryinstalled` into the command below. The package ID may not be the same for all users, so you need to complete this step using the package ID returned from your console."
msgstr ""

#: ../../source/channel_update_tutorial.rst:671
msgid "Use the following command to approve a definition of the  ``mycc`` chaincode for Org3:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:681
msgid "You can use the ``peer lifecycle chaincode querycommitted`` command to check if the chaincode definition you have approved has already been committed to the channel."
msgstr ""

#: ../../source/channel_update_tutorial.rst:690
msgid "A successful command will return information about the committed definition:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:697
msgid "Since the chaincode definition has already been committed, you are ready to use the ``mycc`` chaincode after you approve the definition. The chaincode definition uses the default endorsement policy, which requires a majority of organizations on the channel endorse a transaction. This implies that if an organization is added to or removed from the channel, the endorsement policy is updated automatically. We previously needed endorsements from Org1 and Org2 (2 out of 2). Now we need endorsements from two organizations out of Org1, Org2, and Org3 (2 out of 3)."
msgstr ""

#: ../../source/channel_update_tutorial.rst:706
msgid "Query the chaincode to ensure that it has started. Note that you may need to wait for the chaincode container to start."
msgstr ""

#: ../../source/channel_update_tutorial.rst:713
msgid "We should see a response of ``Query Result: 90``."
msgstr ""

#: ../../source/channel_update_tutorial.rst:715
msgid "Now issue an invocation to move ``10`` from ``a`` to ``b``. In the command below, we target a peer in Org1 and Org3 to collect a sufficient number of endorsements."
msgstr ""

#: ../../source/channel_update_tutorial.rst:723
msgid "Query one final time:"
msgstr ""

#: ../../source/channel_update_tutorial.rst:729
msgid "We should see a response of ``Query Result: 80``, accurately reflecting the update of this chaincode's world state."
msgstr ""

#: ../../source/channel_update_tutorial.rst:733
msgid "Conclusion"
msgstr ""

#: ../../source/channel_update_tutorial.rst:735
msgid "The channel configuration update process is indeed quite involved, but there is a logical method to the various steps. The endgame is to form a delta transaction object represented in protobuf binary format and then acquire the requisite number of admin signatures such that the channel configuration update transaction fulfills the channel's modification policy."
msgstr ""

#: ../../source/channel_update_tutorial.rst:741
msgid "The ``configtxlator`` and ``jq`` tools, along with the ever-growing ``peer channel`` commands, provide us with the functionality to accomplish this task."
msgstr ""

