# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 王伟兵 <wbwang@inspur.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-23 09:48+0800\n"
"PO-Revision-Date: 2019-04-22 19:57+0000\n"
"Last-Translator: 王伟兵 <wbwang@inspur.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/hyperledger/teams/97220/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/arch-deep-dive.rst:2
msgid "Architecture Origins"
msgstr "架构起源"

#: ../../source/arch-deep-dive.rst:4
msgid ""
"This document represents the initial architectural proposal for Hyperledger "
"Fabric v1.0. While the Hyperledger Fabric implementation has conceptually "
"followed from the architectural proposal, some details have been altered "
"during the implementation. The initial architectural proposal is presented "
"as originally prepared. For a more technically accurate representation of "
"the architecture, please see `Hyperledger Fabric: A Distributed Operating "
"System for Permissioned Blockchains <https://arxiv.org/abs/1801.10228v2>`__."
msgstr ""
"本文档表现了Hyperledger Fabric v1.0的初始架构提案。虽然Hyperledger "
"Fabric实现在概念上遵循了本架构提案，但是在实现过程中一些细节已经被更改。最初的架构方案是按照最初准备的方式呈现的。要更精确地表示架构，请参见`Hyperledger"
" Fabric:一个许可区块链的分布式操作系统<https://arxiv.org/abs/1801.10228v2>`__。"

#: ../../source/arch-deep-dive.rst:13
msgid "The Hyperledger Fabric architecture delivers the following advantages:"
msgstr "超级账本Fabric架构具有以下优点:"

#: ../../source/arch-deep-dive.rst:15
msgid ""
"**Chaincode trust flexibility.** The architecture separates *trust "
"assumptions* for chaincodes (blockchain applications) from trust assumptions"
" for ordering. In other words, the ordering service may be provided by one "
"set of nodes (orderers) and tolerate some of them to fail or misbehave, and "
"the endorsers may be different for each chaincode."
msgstr ""
"链码**链码信任的灵活性**该架构将链码(区块链应用程序)的*信任假设*与排序的信任假设分开。换句话说，排序服务可能由一组节点(排序器)提供，并允许其中一些节点失败或行为不端，而且每个链码的背书者可能不同。"

#: ../../source/arch-deep-dive.rst:22
msgid ""
"**Scalability.** As the endorser nodes responsible for particular chaincode "
"are orthogonal to the orderers, the system may *scale* better than if these "
"functions were done by the same nodes. In particular, this results when "
"different chaincodes specify disjoint endorsers, which introduces a "
"partitioning of chaincodes between endorsers and allows parallel chaincode "
"execution (endorsement). Besides, chaincode execution, which can potentially"
" be costly, is removed from the critical path of the ordering service."
msgstr ""
"**可伸缩性** "
"由于负责特定链码的背书节点与排序器正交，因此系统的伸缩性可能比由相同节点执行这些功能要好。特别是，当不同的链码指定了互斥的背书器时，这将导致在背书器之间对链码进行分区，并允许并行的链码执行(背书)。此外，链码执行从排序服务的关键路径中删除，链码执行的成本可能很高。"

#: ../../source/arch-deep-dive.rst:31
msgid ""
"**Confidentiality.** The architecture facilitates deployment of chaincodes "
"that have *confidentiality* requirements with respect to the content and "
"state updates of its transactions."
msgstr "**机密性。**本架构有助于部署对其交易的内容和状态更新具有“机密性”要求的链码。"

#: ../../source/arch-deep-dive.rst:35
msgid ""
"**Consensus modularity.** The architecture is *modular* and allows pluggable"
" consensus (i.e., ordering service) implementations."
msgstr "**共识模块化。**该架构是*模块化的*，允许可插入的共识算法(即，排序服务)实现。"

#: ../../source/arch-deep-dive.rst:38
msgid ""
"**Part I: Elements of the architecture relevant to Hyperledger Fabric v1**"
msgstr "**第一部分:与Hyperledger Fabric v1**相关的架构元素"

#: ../../source/arch-deep-dive.rst:41
msgid "System architecture"
msgstr "系统架构"

#: ../../source/arch-deep-dive.rst:42
msgid "Basic workflow of transaction endorsement"
msgstr "交易背书的基本流程"

#: ../../source/arch-deep-dive.rst:43
msgid "Endorsement policies"
msgstr "背书策略"

#: ../../source/arch-deep-dive.rst:45
msgid "**Part II: Post-v1 elements of the architecture**"
msgstr "**第二部分:架构的Post-v1 元素**"

#: ../../source/arch-deep-dive.rst:47
msgid "Ledger checkpointing (pruning)"
msgstr "账本检查点(修剪)"

#: ../../source/arch-deep-dive.rst:50
msgid "1. System architecture"
msgstr "1. 系统架构"

#: ../../source/arch-deep-dive.rst:52
msgid ""
"The blockchain is a distributed system consisting of many nodes that "
"communicate with each other. The blockchain runs programs called chaincode, "
"holds state and ledger data, and executes transactions. The chaincode is the"
" central element as transactions are operations invoked on the chaincode. "
"Transactions have to be \"endorsed\" and only endorsed transactions may be "
"committed and have an effect on the state. There may exist one or more "
"special chaincodes for management functions and parameters, collectively "
"called *system chaincodes*."
msgstr ""
"区块链是一个分布式系统，由许多相互通信的节点组成。区块链运行名为链码的程序，保存状态和账本数据，并执行交易。链码是中心元素，因为交易是在链码上调用的操作。交易必须“背书”，只有背书的交易才可以提交并对状态产生影响。可能存在一个或多个用于管理函数和参数的特殊链码，统称为*系统链码*。"

#: ../../source/arch-deep-dive.rst:62
msgid "1.1. Transactions"
msgstr "1.1. 交易"

#: ../../source/arch-deep-dive.rst:64
msgid "Transactions may be of two types:"
msgstr "交易可分为两类:"

#: ../../source/arch-deep-dive.rst:66
msgid ""
"*Deploy transactions* create new chaincode and take a program as parameter. "
"When a deploy transaction executes successfully, the chaincode has been "
"installed \"on\" the blockchain."
msgstr "*部署交易*创建新的链码并将程序作为参数。当部署交易成功执行时，链码会被安装在区块链上。"

#: ../../source/arch-deep-dive.rst:70
msgid ""
"*Invoke transactions* perform an operation in the context of previously "
"deployed chaincode. An invoke transaction refers to a chaincode and to one "
"of its provided functions. When successful, the chaincode executes the "
"specified function - which may involve modifying the corresponding state, "
"and returning an output."
msgstr ""
"*调用交易*在以前部署的链码上下文中执行操作。调用交易引用链码和它提供的某个函数。当成功时，链码执行指定的函数，这可能涉及修改相应的状态，并返回输出。"

#: ../../source/arch-deep-dive.rst:76
msgid ""
"As described later, deploy transactions are special cases of invoke "
"transactions, where a deploy transaction that creates new chaincode, "
"corresponds to an invoke transaction on a system chaincode."
msgstr "如后面所述，部署交易是调用交易的特殊情况，其中创建新链码的部署交易对应于系统链码上的调用交易。"

#: ../../source/arch-deep-dive.rst:80
msgid ""
"**Remark:** *This document currently assumes that a transaction either "
"creates new chaincode or invokes an operation provided by *one* already "
"deployed chaincode. This document does not yet describe: a) optimizations "
"for query (read-only) transactions (included in v1), b) support for cross-"
"chaincode transactions (post-v1 feature).*"
msgstr ""
"**备注:** *本文档目前假设交易要么创建新的链码，要么调用*一个*已部署链码提供的操作。这个文档还没有描述: "
"a)查询(只读)交易的优化(包含在v1中)，b)对跨链码交易的支持(v1后续的特性).*"

#: ../../source/arch-deep-dive.rst:87
msgid "1.2. Blockchain datastructures"
msgstr "1.2. 区块链数据结构"

#: ../../source/arch-deep-dive.rst:90
msgid "1.2.1. State"
msgstr "1.2.1 状态"

#: ../../source/arch-deep-dive.rst:92
msgid ""
"The latest state of the blockchain (or, simply, *state*) is modeled as a "
"versioned key-value store (KVS), where keys are names and values are "
"arbitrary blobs. These entries are manipulated by the chaincodes "
"(applications) running on the blockchain through ``put`` and ``get`` KVS-"
"operations. The state is stored persistently and updates to the state are "
"logged. Notice that versioned KVS is adopted as state model, an "
"implementation may use actual KVSs, but also RDBMSs or any other solution."
msgstr ""
"区块链的最新状态(或者简单地说，*状态*)被建模为一个版本化的键值存储(KVS)，其中键是名称，值是任意的blob。这些条目由区块链上运行的链码(应用程序)通过“put”和“get"
"”KVS-"
"操作操作。状态被持久地存储，并记录对状态的更新。注意，版本化的KVS被用作状态模型，实现可以使用既有的KVS，也可以使用RDBMS或任何其他解决方案。"

#: ../../source/arch-deep-dive.rst:101
msgid ""
"More formally, state ``s`` is modeled as an element of a mapping ``K -> (V X"
" N)``, where:"
msgstr "更正式地说，状态``s`` 被建模为映射``K -> (V X N)``的一个元素，其中:"

#: ../../source/arch-deep-dive.rst:104
msgid "``K`` is a set of keys"
msgstr "``K``是一组键"

#: ../../source/arch-deep-dive.rst:105
msgid "``V`` is a set of values"
msgstr "``V`` 是一组值"

#: ../../source/arch-deep-dive.rst:106
msgid ""
"``N`` is an infinite ordered set of version numbers. Injective function "
"``next: N -> N`` takes an element of ``N`` and returns the next version "
"number."
msgstr "``N``是版本号的无穷有序集合。单射函数 ``next: N -> N`` 接受``N``的元素并返回下一个版本号。"

#: ../../source/arch-deep-dive.rst:110
msgid ""
"Both ``V`` and ``N`` contain a special element |falsum| (empty type), which "
"is in case of ``N`` the lowest element. Initially all keys are mapped to "
"(|falsum|, |falsum|). For ``s(k)=(v,ver)`` we denote ``v`` by "
"``s(k).value``, and ``ver`` by ``s(k).version``."
msgstr ""
" ``V``和``N`` 都包含一个特殊的元素|falsum|(空类型)，即``N`` 是最低的元素。最初，所有键都映射到(|falsum|, "
"|falsum|)。对于``s(k)=(v,ver)``，我们用``s(k).value``表示``v``，  "
"用``s(k).version``表示``ver`` 。"

#: ../../source/arch-deep-dive.rst:118
msgid "KVS operations are modeled as follows:"
msgstr "KVS操作模型如下:"

#: ../../source/arch-deep-dive.rst:120
msgid ""
"``put(k,v)`` for ``k`` |in| ``K`` and ``v`` |in| ``V``, takes the blockchain"
" state ``s`` and changes it to ``s'`` such that "
"``s'(k)=(v,next(s(k).version))`` with ``s'(k')=s(k')`` for all ``k'!=k``."
msgstr ""
"``put(k,v)`` for ``k`` |in| ``K`` and ``v`` |in| ``V``, 将区块链状态设置为 "
"``s``，然后将状态修改为 ``s'`` ，于是 ``s'(k)=(v,next(s(k).version))`` with "
"``s'(k')=s(k')`` for all ``k'!=k``."

#: ../../source/arch-deep-dive.rst:124
msgid "``get(k)`` returns ``s(k)``."
msgstr "``get(k)`` 返回``s(k)``。"

#: ../../source/arch-deep-dive.rst:126
msgid "State is maintained by peers, but not by orderers and clients."
msgstr "状态由节点维护，而不是由排序器和客户端维护。"

#: ../../source/arch-deep-dive.rst:128
msgid ""
"**State partitioning.** Keys in the KVS can be recognized from their name to"
" belong to a particular chaincode, in the sense that only transaction of a "
"certain chaincode may modify the keys belonging to this chaincode. In "
"principle, any chaincode can read the keys belonging to other chaincodes. "
"*Support for cross-chaincode transactions, that modify the state belonging "
"to two or more chaincodes is a post-v1 feature.*"
msgstr ""
"**状态分区。**KVS中的键可以从它们的名称中识别出属于某个特定链码，因为只有某个链码的交易可以修改属于这个链码的键。原则上，任何链码都可以读取属于其他链码的键。*支持跨链码交易，可以修改属于两个或多个链码的状态，这是一个v1后续版本的特性。*"

#: ../../source/arch-deep-dive.rst:136
msgid "1.2.2 Ledger"
msgstr "1.2.2 账本"

#: ../../source/arch-deep-dive.rst:138
msgid ""
"Ledger provides a verifiable history of all successful state changes (we "
"talk about *valid* transactions) and unsuccessful attempts to change state "
"(we talk about *invalid* transactions), occurring during the operation of "
"the system."
msgstr ""
"账本提供了一个可验证的历史记录，记录了在系统运行期间发生的所有成功的状态更改(我们说的*有效的*交易)和失败的状态更改尝试(我们说的*无效的*交易)。"

#: ../../source/arch-deep-dive.rst:143
msgid ""
"Ledger is constructed by the ordering service (see Sec 1.3.3) as a totally "
"ordered hashchain of *blocks* of (valid or invalid) transactions. The "
"hashchain imposes the total order of blocks in a ledger and each block "
"contains an array of totally ordered transactions. This imposes total order "
"across all transactions."
msgstr ""
"账本是由排序服务(参见第1.3.3节)构造的，它是(有效或无效的)交易的*区块*的完全有序哈希链。哈希链强制账本中的区块的总顺序，每个区块包含一个完全有序的交易数组。这强制为所有交易指定了顺序。"

#: ../../source/arch-deep-dive.rst:149
msgid ""
"Ledger is kept at all peers and, optionally, at a subset of orderers. In the"
" context of an orderer we refer to the Ledger as to ``OrdererLedger``, "
"whereas in the context of a peer we refer to the ledger as to "
"``PeerLedger``. ``PeerLedger`` differs from the ``OrdererLedger`` in that "
"peers locally maintain a bitmask that tells apart valid transactions from "
"invalid ones (see Section XX for more details)."
msgstr ""
"账本保存在所有的节点上，也可以选择保存在部分排序器上。在排序器的上下文中，我们将账本称为“排序器账本”，而在节点的上下文中，我们将账本称为“节点账本”。``节点账本``"
" 与``排序器账本`` 的不同之处在于，节点在本地维护一个比特掩码，该比特掩码将有效的交易与无效的交易区分开来(有关详细信息，请参阅XX节)。"

#: ../../source/arch-deep-dive.rst:157
msgid ""
"Peers may prune ``PeerLedger`` as described in Section XX (post-v1 feature)."
" Orderers maintain ``OrdererLedger`` for fault-tolerance and availability "
"(of the ``PeerLedger``) and may decide to prune it at anytime, provided that"
" properties of the ordering service (see Sec. 1.3.3) are maintained."
msgstr ""
"如第XX节(v1后续特性)所述的，节点可以修剪 ``节点账本`` "
"。排序器维护“排序器账本”以获得容错性和(“节点账本”的)可用性，并可以决定随时对其进行修剪，前提是排序服务的属性得到了维护(参见第1.3.3节)。"

#: ../../source/arch-deep-dive.rst:163
msgid ""
"The ledger allows peers to replay the history of all transactions and to "
"reconstruct the state. Therefore, state as described in Sec 1.2.1 is an "
"optional datastructure."
msgstr "账本允许节点重放所有交易的历史并重建状态。因此，Sec 1.2.1中描述的状态是一个可选的数据结构。"

#: ../../source/arch-deep-dive.rst:168
msgid "1.3. Nodes"
msgstr "1.3. node节点"

#: ../../source/arch-deep-dive.rst:170
msgid ""
"Nodes are the communication entities of the blockchain. A \"node\" is only a"
" logical function in the sense that multiple nodes of different types can "
"run on the same physical server. What counts is how nodes are grouped in "
"\"trust domains\" and associated to logical entities that control them."
msgstr ""
"node节点是区块链的通信实体。一个“node节点”只是一个逻辑功能，因为不同类型的多个node节点可以运行在同一个物理服务器上。重要的是node节点如何在“信任域”中分组并与控制它们的逻辑实体相关联。"

#: ../../source/arch-deep-dive.rst:176
msgid "There are three types of nodes:"
msgstr "有三种类型的node节点："

#: ../../source/arch-deep-dive.rst:178
msgid ""
"**Client** or **submitting-client**: a client that submits an actual "
"transaction-invocation to the endorsers, and broadcasts transaction-"
"proposals to the ordering service."
msgstr "**客户端**或**提交客户端**：是一个向背书方提交实际交易调用并向排序服务广播交易提议的客户端。"

#: ../../source/arch-deep-dive.rst:182
msgid ""
"**Peer**: a node that commits transactions and maintains the state and a "
"copy of the ledger (see Sec, 1.2). Besides, peers can have a special "
"**endorser** role."
msgstr ""
"**peer节点**：是一个提交交易并维护状态和账本副本的node节点(参见第1.2节)。此外，peer节点可以扮演一个特殊的**背书人**角色。"

#: ../../source/arch-deep-dive.rst:186
msgid ""
"**Ordering-service-node** or **orderer**: a node running the communication "
"service that implements a delivery guarantee, such as atomic or total order "
"broadcast."
msgstr "**排序服务node节点**或**排序器**：是一个运行实现交付担保的通信服务的node节点，例如原子性或总顺序广播。"

#: ../../source/arch-deep-dive.rst:190
msgid "The types of nodes are explained next in more detail."
msgstr "接下来将更详细地解释node节点的类型。"

#: ../../source/arch-deep-dive.rst:193
msgid "1.3.1. Client"
msgstr "1.3.1. 客户端"

#: ../../source/arch-deep-dive.rst:195
msgid ""
"The client represents the entity that acts on behalf of an end-user. It must"
" connect to a peer for communicating with the blockchain. The client may "
"connect to any peer of its choice. Clients create and thereby invoke "
"transactions."
msgstr "客户端扮演了代表最终用户的实体。它必须连接到与区块链通信的peer节点。客户端可以连接到它所选择的任何peer节点。客户端创建并调用交易。"

#: ../../source/arch-deep-dive.rst:200
msgid ""
"As detailed in Section 2, clients communicate with both peers and the "
"ordering service."
msgstr "如第2节所详细介绍的，客户端同时与peer节点和排序服务通信。"

#: ../../source/arch-deep-dive.rst:204
msgid "1.3.2. Peer"
msgstr "1.3.2. peer节点"

#: ../../source/arch-deep-dive.rst:206
msgid ""
"A peer receives ordered state updates in the form of *blocks* from the "
"ordering service and maintain the state and the ledger."
msgstr "peer节点接收来自排序服务的“区块”形式的有序状态更新，并维护状态和账本。"

#: ../../source/arch-deep-dive.rst:209
msgid ""
"Peers can additionally take up a special role of an **endorsing peer**, or "
"an **endorser**. The special function of an *endorsing peer* occurs with "
"respect to a particular chaincode and consists in *endorsing* a transaction "
"before it is committed. Every chaincode may specify an *endorsement policy* "
"that may refer to a set of endorsing peers. The policy defines the necessary"
" and sufficient conditions for a valid transaction endorsement (typically a "
"set of endorsers' signatures), as described later in Sections 2 and 3. In "
"the special case of deploy transactions that install new chaincode the "
"(deployment) endorsement policy is specified as an endorsement policy of the"
" system chaincode."
msgstr ""
"链码peer节点还可以承担**背书节点**或**背书人**的特殊角色。一个*背书节点*的特殊函数根据一个特定链码重现，包括在交易提交之前*背书*一个交易。每个链码都可以指定一个*背书策略*，该策略可以引用一组背书节点。策略为有效的交易背书(通常是一组背书人的签名)定义了必要条件和充分条件，后面的第2和3节将对此进行描述。在安装新链码的部署交易的特殊情况下，(部署)背书策略指定为系统链码的背书策略。"

#: ../../source/arch-deep-dive.rst:221
msgid "1.3.3. Ordering service nodes (Orderers)"
msgstr "1.3.3. 排序服务node节点（排序器）"

#: ../../source/arch-deep-dive.rst:223
msgid ""
"The *orderers* form the *ordering service*, i.e., a communication fabric "
"that provides delivery guarantees. The ordering service can be implemented "
"in different ways: ranging from a centralized service (used e.g., in "
"development and testing) to distributed protocols that target different "
"network and node fault models."
msgstr ""
"*排序器*组成*排序服务*，即，提供交付担保的通信结构。排序服务可以以不同的方式实现：从集中式服务(例如，在开发和测试中使用)到针对不同网络和node节点故障模型的分布式协议。"

#: ../../source/arch-deep-dive.rst:229
msgid ""
"Ordering service provides a shared *communication channel* to clients and "
"peers, offering a broadcast service for messages containing transactions. "
"Clients connect to the channel and may broadcast messages on the channel "
"which are then delivered to all peers. The channel supports *atomic* "
"delivery of all messages, that is, message communication with total-order "
"delivery and (implementation specific) reliability. In other words, the "
"channel outputs the same messages to all connected peers and outputs them to"
" all peers in the same logical order. This atomic communication guarantee is"
" also called *total-order broadcast*, *atomic broadcast*, or *consensus* in "
"the context of distributed systems. The communicated messages are the "
"candidate transactions for inclusion in the blockchain state."
msgstr ""
"排序服务为客户端和peer节点提供共享的“通信通道”，为包含交易的消息提供广播服务。客户端连接到通道，并可以在通道上广播消息，然后将消息传递给所有peer节点。该通道支持所有消息的“原子”传递，即与全顺序传递和(特定于实现的)可靠性的消息通信。换句话说，通道将相同的消息输出给所有连接的peer节点，并将它们以相同的逻辑顺序输出给所有peer节点。这种原子通信保证在分布式系统上下文中也称为*全顺序广播*、*原子广播*或*共识*。所通信的消息是要包含在区块链状态中的候选交易。"

#: ../../source/arch-deep-dive.rst:242
msgid ""
"**Partitioning (ordering service channels).** Ordering service may support "
"multiple *channels* similar to the *topics* of a publish/subscribe (pub/sub)"
" messaging system. Clients can connect to a given channel and can then send "
"messages and obtain the messages that arrive. Channels can be thought of as "
"partitions - clients connecting to one channel are unaware of the existence "
"of other channels, but clients may connect to multiple channels. Even though"
" some ordering service implementations included with Hyperledger Fabric "
"support multiple channels, for simplicity of presentation, in the rest of "
"this document, we assume ordering service consists of a single "
"channel/topic."
msgstr ""
"**分区(排序服务通道)。**排序服务可能支持多个*通道*，类似于发布/订阅(发布/订阅)消息系统的*主题*。客户端可以连接到给定的通道，然后可以发送消息并获取到达的消息。通道可以看作是分区，连接到一个通道的客户端不知道其他通道的存在，但是客户端可以连接到多个通道。尽管在超级账本Fabric中包含的一些排序服务实现支持多个通道，但为了简化表示，在本文档的其余部分中，我们假设排序服务由一个通道/主题组成。"

#: ../../source/arch-deep-dive.rst:253
msgid ""
"**Ordering service API.** Peers connect to the channel provided by the "
"ordering service, via the interface provided by the ordering service. The "
"ordering service API consists of two basic operations (more generally "
"*asynchronous events*):"
msgstr ""
"**排序服务API。**peer节点通过排序服务提供的接口连接到排序服务提供的通道。排序服务API由两个基本操作(一般称*异步事件*)组成:"

#: ../../source/arch-deep-dive.rst:258
msgid ""
"**TODO** add the part of the API for fetching particular blocks under "
"client/peer specified sequence numbers."
msgstr "**TODO** 添加API的一部分，用于在客户端/peer节点指定的序列号下获取特定的区块。"

#: ../../source/arch-deep-dive.rst:261
msgid ""
"``broadcast(blob)``: a client calls this to broadcast an arbitrary message "
"``blob`` for dissemination over the channel. This is also called "
"``request(blob)`` in the BFT context, when sending a request to a service."
msgstr ""
"``广播(blob) "
"``:客户端调用它来广播任意消息``blob``以便在通道上传播。在BFT上下文中，当向服务发送请求时，也称为``request(blob)``。"

#: ../../source/arch-deep-dive.rst:266
msgid ""
"``deliver(seqno, prevhash, blob)``: the ordering service calls this on the "
"peer to deliver the message ``blob`` with the specified non-negative integer"
" sequence number (``seqno``) and hash of the most recently delivered blob "
"(``prevhash``). In other words, it is an output event from the ordering "
"service. ``deliver()`` is also sometimes called ``notify()`` in pub-sub "
"systems or ``commit()`` in BFT systems."
msgstr ""
"``deliver(seqno, prevhash, blob)``:排序服务在peer节点调用这个函数，以传递消息``blob`` "
"，其中包含指定的非负整数序列号 "
"(``seqno``)和最近交付的blob的散列(``prevhash``)。换句话说，它是来自排序服务的输出事件。``deliver()``在发布订阅系统中有时也被称为`notify()``，或在BFT系统中被称为``commit()``。"

#: ../../source/arch-deep-dive.rst:274
msgid ""
"**Ledger and block formation.** The ledger (see also Sec. 1.2.2) contains "
"all data output by the ordering service. In a nutshell, it is a sequence of "
"``deliver(seqno, prevhash, blob)`` events, which form a hash chain according"
" to the computation of ``prevhash`` described before."
msgstr ""
"账本和区块构成。账本(参见第1.2.2节)包含排序服务输出的所有数据。简而言之，它是``deliver(seqno, prevhash, "
"blob)``事件的序列，这些事件根据前面描述的``prevhash`` 的计算形成一个哈希链。"

#: ../../source/arch-deep-dive.rst:279
msgid ""
"Most of the time, for efficiency reasons, instead of outputting individual "
"transactions (blobs), the ordering service will group (batch) the blobs and "
"output *blocks* within a single ``deliver`` event. In this case, the "
"ordering service must impose and convey a deterministic ordering of the "
"blobs within each block. The number of blobs in a block may be chosen "
"dynamically by an ordering service implementation."
msgstr ""
"大多数时候，出于效率的考虑，排序服务不会输出单个交易(blob)，而是在单个``deliver``事件中对blob和输出*区块*进行分组(批处理)。在这种情况下，排序服务必须强制并传递每个区块中blob的确定性排序。区块中的区块数可以由排序服务实现动态选择。"

#: ../../source/arch-deep-dive.rst:286
msgid ""
"In the following, for ease of presentation, we define ordering service "
"properties (rest of this subsection) and explain the workflow of transaction"
" endorsement (Section 2) assuming one blob per ``deliver`` event. These are "
"easily extended to blocks, assuming that a ``deliver`` event for a block "
"corresponds to a sequence of individual ``deliver`` events for each blob "
"within a block, according to the above mentioned deterministic ordering of "
"blobs within a block."
msgstr ""
"下面，为了便于表达，我们定义了排序服务属性(本小节的其余部分)，并解释了交易背书的工作流(第2节)，假设每个``deliver`` "
"事件有一个blob。这些很容易扩展到区块，假设一个区块的“交付”事件对应于一个区块中的每个blob的单独的 "
"``deliver``事件序列，根据上面提到的区块中blob的确定性顺序。"

#: ../../source/arch-deep-dive.rst:294
msgid "**Ordering service properties**"
msgstr "**排序服务属性**"

#: ../../source/arch-deep-dive.rst:296
msgid ""
"The guarantees of the ordering service (or atomic-broadcast channel) "
"stipulate what happens to a broadcasted message and what relations exist "
"among delivered messages. These guarantees are as follows:"
msgstr "排序服务(或原子广播通道)的保证规定了广播消息发生了什么，以及传递的消息之间存在什么关系。这些保证如下:"

#: ../../source/arch-deep-dive.rst:300
msgid ""
"**Safety (consistency guarantees)**: As long as peers are connected for "
"sufficiently long periods of time to the channel (they can disconnect or "
"crash, but will restart and reconnect), they will see an *identical* series "
"of delivered ``(seqno, prevhash, blob)`` messages. This means the outputs "
"(``deliver()`` events) occur in the *same order* on all peers and according "
"to sequence number and carry *identical content* (``blob`` and ``prevhash``)"
" for the same sequence number. Note this is only a *logical order*, and a "
"``deliver(seqno, prevhash, blob)`` on one peer is not required to occur in "
"any real-time relation to ``deliver(seqno, prevhash, blob)`` that outputs "
"the same message at another peer. Put differently, given a particular "
"``seqno``, *no* two correct peers deliver *different* ``prevhash`` or "
"``blob`` values. Moreover, no value ``blob`` is delivered unless some client"
" (peer) actually called ``broadcast(blob)`` and, preferably, every "
"broadcasted blob is only delivered *once*."
msgstr ""
"**安全(一致性保证)**:只要peer节点连接到通道的时间足够长(它们可以断开连接或崩溃，但会重新启动和重新连接)，它们将看到一个*相同的*已交付的``(seqno,"
" prevhash, blob)`` "
"消息序列。这意味着输出(``deliver()``事件)在所有peer节点上以*相同的顺序*发生，并根据序列号，为相同的序列号携带*相同的内容* "
"(``blob`` 和``prevhash``)。注意，这只是一个“逻辑顺序”，一个peer节点上的``deliver(seqno, prevhash,"
" blob)`` 不需要与另一个peer节点上输出相同的``deliver(seqno, prevhash, blob)`` "
"消息发生实时关联。换句话说，给定一个特定的'``seqno``， *没有*两个正确的peer节点提供了*不同的*``prevhash`` "
"或``blob`` '值。此外，除非某个客户端（peer节点）实际调用了``broadcast(blob)`` ，否则不会传递任何值``blob`` "
"，即每个广播的blob只传递*一次*。"

#: ../../source/arch-deep-dive.rst:317
msgid ""
"Furthermore, the ``deliver()`` event contains the cryptographic hash of the "
"data in the previous ``deliver()`` event (``prevhash``). When the ordering "
"service implements atomic broadcast guarantees, ``prevhash`` is the "
"cryptographic hash of the parameters from the ``deliver()`` event with "
"sequence number ``seqno-1``. This establishes a hash chain across "
"``deliver()`` events, which is used to help verify the integrity of the "
"ordering service output, as discussed in Sections 4 and 5 later. In the "
"special case of the first ``deliver()`` event, ``prevhash`` has a default "
"value."
msgstr ""
"此外，``deliver()``事件包含前一个``deliver()`` "
"事件中的数据的加密哈希(``prevhash``)。当排序服务实现原子广播保证时，``prevhash``是``deliver()``事件的参数和序号的加密哈希``seqno-1``。这将在``deliver()``事件之间建立一个哈希链，用于帮助验证排序服务输出的完整性，后面的第4和第5节将对此进行讨论。在第一个``deliver()``事件的特殊情况下，``prevhash``有一个默认值。"

#: ../../source/arch-deep-dive.rst:327
msgid ""
"**Liveness (delivery guarantee)**: Liveness guarantees of the ordering "
"service are specified by a ordering service implementation. The exact "
"guarantees may depend on the network and node fault model."
msgstr "**存活性(交付保证)**:排序服务的存活性保证由排序服务的实现决定。准确的保证可能取决于网络和node节点故障模型。"

#: ../../source/arch-deep-dive.rst:331
msgid ""
"In principle, if the submitting client does not fail, the ordering service "
"should guarantee that every correct peer that connects to the ordering "
"service eventually delivers every submitted transaction."
msgstr "原则上，如果提交的客户端没有失败，那么排序服务应该确保连接到排序服务的每个正确peer节点最终交付每个提交的交易。"

#: ../../source/arch-deep-dive.rst:335
msgid "To summarize, the ordering service ensures the following properties:"
msgstr "总而言之，排序服务确保以下特性:"

#: ../../source/arch-deep-dive.rst:337
msgid ""
"*Agreement.* For any two events at correct peers ``deliver(seqno, prevhash0,"
" blob0)`` and ``deliver(seqno, prevhash1, blob1)`` with the same ``seqno``, "
"``prevhash0==prevhash1`` and ``blob0==blob1``;"
msgstr ""
"*协议。*对于正确peer节点上的任何两个具有相同 ``seqno``的事件``deliver(seqno, prevhash0, blob0)`` "
"和``deliver(seqno, prevhash1, blob1)`` "
"，``prevhash0==prevhash1``和``blob0==blob1``;"

#: ../../source/arch-deep-dive.rst:341
msgid ""
"*Hashchain integrity.* For any two events at correct peers "
"``deliver(seqno-1, prevhash0, blob0)`` and ``deliver(seqno, prevhash, "
"blob)``, ``prevhash = HASH(seqno-1||prevhash0||blob0)``."
msgstr ""
"*哈希链完整性。* 对于正确peer节点上的任何两个事件``deliver(seqno-1, prevhash0, blob0)`` 和 "
"``deliver(seqno, prevhash, blob)``, ``prevhash = "
"HASH(seqno-1||prevhash0||blob0)``。"

#: ../../source/arch-deep-dive.rst:345
msgid ""
"*No skipping*. If an ordering service outputs ``deliver(seqno, prevhash, "
"blob)`` at a correct peer *p*, such that ``seqno>0``, then *p* already "
"delivered an event ``deliver(seqno-1, prevhash0, blob0)``."
msgstr ""
"*没有跳过*。如果排序服务在一个正确的peer节点*p*上输出``deliver(seqno, prevhash, blob)`` ，例如 "
"``seqno>0``，那么*p*已经交付了一个事件``deliver(seqno-1, prevhash0, blob0)``。"

#: ../../source/arch-deep-dive.rst:349
msgid ""
"*No creation*. Any event ``deliver(seqno, prevhash, blob)`` at a correct "
"peer must be preceded by a ``broadcast(blob)`` event at some (possibly "
"distinct) peer;"
msgstr ""
"*没有创建*。在正确的peer节点上的任何事件``deliver(seqno, prevhash, "
"blob)``之前，在一些(可能不同的)peer节点上必然有一个``broadcast(blob)``事件;"

#: ../../source/arch-deep-dive.rst:352
msgid ""
"*No duplication (optional, yet desirable)*. For any two events "
"``broadcast(blob)`` and ``broadcast(blob')``, when two events "
"``deliver(seqno0, prevhash0, blob)`` and ``deliver(seqno1, prevhash1, "
"blob')`` occur at correct peers and ``blob == blob'``, then "
"``seqno0==seqno1`` and ``prevhash0==prevhash1``."
msgstr ""
"*没有复制duplication (optional, yet desirable)*。对任何两个事件``broadcast(blob)`` "
"和``broadcast(blob')``，当两个事件``deliver(seqno0, prevhash0, blob)`` 和 "
"``deliver(seqno1, prevhash1, blob')``发生在正确的peer节点并且 ``blob == "
"blob'``，那么``seqno0==seqno1``和``prevhash0==prevhash1``。"

#: ../../source/arch-deep-dive.rst:358
msgid ""
"*Liveness*. If a correct client invokes an event ``broadcast(blob)`` then "
"every correct peer \"eventually\" issues an event ``deliver(*, *, blob)``, "
"where ``*`` denotes an arbitrary value."
msgstr ""
"*存活性*。如果一个正确的客户端调用一个事件``broadcast(blob)`` "
"，那么每个正确的peer节点“最终”发出一个事件``deliver(*, *, blob)``，其中 ``*`` 表示一个任意值。"

#: ../../source/arch-deep-dive.rst:363
msgid "2. Basic workflow of transaction endorsement"
msgstr "2. 交易背书的基本流程"

#: ../../source/arch-deep-dive.rst:365
msgid ""
"In the following we outline the high-level request flow for a transaction."
msgstr "在下面的文章中，我们将概述交易的高级请求流程。"

#: ../../source/arch-deep-dive.rst:368
msgid ""
"**Remark:** *Notice that the following protocol *does not* assume that all "
"transactions are deterministic, i.e., it allows for non-deterministic "
"transactions.*"
msgstr "**注:** *注意以下协议*并不*假设所有交易都是确定性的，即，它允许非确定性交易。*"

#: ../../source/arch-deep-dive.rst:373
msgid ""
"2.1. The client creates a transaction and sends it to endorsing peers of its"
" choice"
msgstr "2.1. 客户端创建一个交易并将其发送给它所选择的背书peer节点"

#: ../../source/arch-deep-dive.rst:375
msgid ""
"To invoke a transaction, the client sends a ``PROPOSE`` message to a set of "
"endorsing peers of its choice (possibly not at the same time - see Sections "
"2.1.2. and 2.3.). The set of endorsing peers for a given ``chaincodeID`` is "
"made available to client via peer, which in turn knows the set of endorsing "
"peers from endorsement policy (see Section 3). For example, the transaction "
"could be sent to *all* endorsers of a given ``chaincodeID``. That said, some"
" endorsers could be offline, others may object and choose not to endorse the"
" transaction. The submitting client tries to satisfy the policy expression "
"with the endorsers available."
msgstr ""
"要引起一个交易，客户端向其选择的一组背书peer节点发送一条“建议”消息(可能不是同时发送，参见2.1.2.节和2.3.节)。客户端可以通过peer节点获得给定“chaincodeID”的背书peer节点集，而peer节点又从背书策略中知道背书peer节点集合（参见第3节）。例如，可以将交易发送给给定``chaincodeID``'的*所有*背书节点。。也就是说，一些背书节点可能离线，其它背书节点可能会反对并选择不背书交易。提交客户端尝试使用可用的背书者来满足策略表达式。"

#: ../../source/arch-deep-dive.rst:386
msgid ""
"In the following, we first detail ``PROPOSE`` message format and then "
"discuss possible patterns of interaction between submitting client and "
"endorsers."
msgstr "在下面，我们首先详细介绍“提议”消息格式，然后讨论提交客户端和背书者之间可能的交互模式。"

#: ../../source/arch-deep-dive.rst:391
msgid "2.1.1. ``PROPOSE`` message format"
msgstr "2.1.1. ``提议``消息格式"

#: ../../source/arch-deep-dive.rst:393
msgid ""
"The format of a ``PROPOSE`` message is ``<PROPOSE,tx,[anchor]>``, where "
"``tx`` is a mandatory and ``anchor`` optional argument explained in the "
"following."
msgstr ""
"：' ' proposal ' '消息的格式是' ' < proposal,tx，[anchor]> ' '，其中' ' tx ' '是必填参数，' ' anchor ' '可选参数解释如下。\n"
"``提议``消息的格式是 ``<PROPOSE,tx,[anchor]>``，其中``tx`` 是必填参数，可选参数 ``anchor`` 解释如下。"

#: ../../source/arch-deep-dive.rst:397
msgid "``tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>``, where"
msgstr "``tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>``, 其中"

#: ../../source/arch-deep-dive.rst:399
msgid "``clientID`` is an ID of the submitting client,"
msgstr "``clientID`` 是提交客户端的ID，"

#: ../../source/arch-deep-dive.rst:400
msgid ""
"``chaincodeID`` refers to the chaincode to which the transaction pertains,"
msgstr "“chaincodeID”指向交易所属的链码，"

#: ../../source/arch-deep-dive.rst:402
msgid ""
"``txPayload`` is the payload containing the submitted transaction itself,"
msgstr "``txPayload``是包含提交交易本身的载荷，"

#: ../../source/arch-deep-dive.rst:404
msgid ""
"``timestamp`` is a monotonically increasing (for every new transaction) "
"integer maintained by the client,"
msgstr "“timestamp”是客户端维护的一个简单递增的整数(对于每个新交易)，"

#: ../../source/arch-deep-dive.rst:406
msgid "``clientSig`` is signature of a client on other fields of ``tx``."
msgstr "“clientSig”是客户端在“tx”的其他字段上的签名。"

#: ../../source/arch-deep-dive.rst:408
msgid ""
"The details of ``txPayload`` will differ between invoke transactions and "
"deploy transactions (i.e., invoke transactions referring to a deploy-"
"specific system chaincode). For an **invoke transaction**, ``txPayload`` "
"would consist of two fields"
msgstr ""
"“txPayload”的详细信息在调用交易和部署交易(即调用交易引用特定于部署的系统链码)是不同的。对于**调用交易**， "
"``txPayload``将包含两个字段"

#: ../../source/arch-deep-dive.rst:413
msgid "``txPayload = <operation, metadata>``, where"
msgstr "``txPayload = <operation, metadata>``, 其中"

#: ../../source/arch-deep-dive.rst:415
msgid ""
"``operation`` denotes the chaincode operation (function) and arguments,"
msgstr "``operation``表示链码操作(函数)和参数，"

#: ../../source/arch-deep-dive.rst:417
msgid "``metadata`` denotes attributes related to the invocation."
msgstr "“metadata”表示与调用相关的属性。"

#: ../../source/arch-deep-dive.rst:419
msgid ""
"For a **deploy transaction**, ``txPayload`` would consist of three fields"
msgstr "对于一个**部署交易**，``txPayload`` 将包含三个字段"

#: ../../source/arch-deep-dive.rst:422
msgid "``txPayload = <source, metadata, policies>``, where"
msgstr "``txPayload = <source, metadata, policies>``, 其中"

#: ../../source/arch-deep-dive.rst:424
msgid "``source`` denotes the source code of the chaincode,"
msgstr "``source`` 表示链码的源代码，"

#: ../../source/arch-deep-dive.rst:425
msgid ""
"``metadata`` denotes attributes related to the chaincode and application,"
msgstr "``metadata`` 表示与链码和应用程序相关的属性，"

#: ../../source/arch-deep-dive.rst:427
msgid ""
"``policies`` contains policies related to the chaincode that are accessible "
"to all peers, such as the endorsement policy. Note that endorsement policies"
" are not supplied with ``txPayload`` in a ``deploy`` transaction, but "
"``txPayload`` of a ``deploy`` contains endorsement policy ID and its "
"parameters (see Section 3)."
msgstr ""
"``policies``包含与链码相关的策略，所有peer节点都可以访问这些策略，例如背书策略。注意，在“部署”事务中的“txPayload”中没有提供背书策略，但是“部署”的“txPayload”包含背书策略ID及其参数(参见第3节)。"

#: ../../source/arch-deep-dive.rst:434
msgid ""
"``anchor`` contains *read version dependencies*, or more specifically, key-"
"version pairs (i.e., ``anchor`` is a subset of ``KxN``), that binds or "
"\"anchors\" the ``PROPOSE`` request to specified versions of keys in a KVS "
"(see Section 1.2.). If the client specifies the ``anchor`` argument, an "
"endorser endorses a transaction only upon *read* version numbers of "
"corresponding keys in its local KVS match ``anchor`` (see Section 2.2. for "
"more details)."
msgstr ""
"``锚定``包含*读取版本依赖项*，或者更具体地说，键版本对儿(即``anchor``是 ``KxN``的子集)，它将 ``提议``请求绑定或 "
"\"锚定\"到KVS中指定版本的键(请参阅1.2.)。如果客户端指定了``锚定``参数，背书者仅在其本地KVS中对应键的*读*版本号匹配``锚定``时才背书交易(更多的细节参见第2.2节)。"

#: ../../source/arch-deep-dive.rst:442
msgid ""
"Cryptographic hash of ``tx`` is used by all nodes as a unique transaction "
"identifier ``tid`` (i.e., ``tid=HASH(tx)``). The client stores ``tid`` in "
"memory and waits for responses from endorsing peers."
msgstr ""
"所有node节点都使用``tx``的加密哈希作为惟一的交易标识符``tid`` "
"(即``tid=HASH(tx)``)。客户端在内存中存储``tid``，并等待来自背书节点的响应。"

#: ../../source/arch-deep-dive.rst:447
msgid "2.1.2. Message patterns"
msgstr "2.1.2. 消息模式"

#: ../../source/arch-deep-dive.rst:449
msgid ""
"The client decides on the sequence of interaction with endorsers. For "
"example, a client would typically send ``<PROPOSE, tx>`` (i.e., without the "
"``anchor`` argument) to a single endorser, which would then produce the "
"version dependencies (``anchor``) which the client can later on use as an "
"argument of its ``PROPOSE`` message to other endorsers. As another example, "
"the client could directly send ``<PROPOSE, tx>`` (without ``anchor``) to all"
" endorsers of its choice. Different patterns of communication are possible "
"and client is free to decide on those (see also Section 2.3.)."
msgstr ""
"客户端决定与背书者交互的顺序。例如，客户端通常会发送``<PROPOSE, tx>`` "
"(即没有“锚定”参数)到单个背书者，这将生成版本依赖关系(“锚定”)，客户端稍后可以将该依赖关系用作其向其他背书者发送的“提议”消息的参数。另一个例子是，客户端可以直接将``<PROPOSE,"
" tx>``(没有'``锚定``)发送给它所选择的所有背书者。不同的通信模式是可能的，客户端可以自由决定这些模式(参见2.3.)。"

#: ../../source/arch-deep-dive.rst:460
msgid ""
"2.2. The endorsing peer simulates a transaction and produces an endorsement "
"signature"
msgstr "2.2. 背书节点模拟交易并生成背书签名"

#: ../../source/arch-deep-dive.rst:462
msgid ""
"On reception of a ``<PROPOSE,tx,[anchor]>`` message from a client, the "
"endorsing peer ``epID`` first verifies the client's signature ``clientSig`` "
"and then simulates a transaction. If the client specifies ``anchor`` then "
"endorsing peer simulates the transactions only upon read version numbers "
"(i.e., ``readset`` as defined below) of corresponding keys in its local KVS "
"match those version numbers specified by ``anchor``."
msgstr ""
"当接收到来自客户端的``<PROPOSE,tx,[anchor]>`` 消息时，背书节点 ``epID`` "
"首先验证客户端的签名``clientSig``，然后模拟一个交易。如果客户端指定“锚定”，则背书节点在它的本地KVS中仅根据键对应的读版本号匹配由 "
"``锚定``指定的版本号。"

#: ../../source/arch-deep-dive.rst:470
msgid ""
"Simulating a transaction involves endorsing peer tentatively *executing* a "
"transaction (``txPayload``), by invoking the chaincode to which the "
"transaction refers (``chaincodeID``) and the copy of the state that the "
"endorsing peer locally holds."
msgstr ""
"通过调用交易引用的链码(“chaincodeID”)和背书节点本地持有的状态副本，模拟交易包括暂时*执行*一个交易(“txPayload”)。"

#: ../../source/arch-deep-dive.rst:475
msgid ""
"As a result of the execution, the endorsing peer computes *read version "
"dependencies* (``readset``) and *state updates* (``writeset``), also called "
"*MVCC+postimage info* in DB language."
msgstr ""
"执行的结果是，背书节点计算*读版本依赖项* (``readset``)和*状态更新* "
"(``writeset``)，在DB语言中也称为*MVCC+postimage info*。"

#: ../../source/arch-deep-dive.rst:479
msgid ""
"Recall that the state consists of key-value pairs. All key-value entries are"
" versioned; that is, every entry contains ordered version information, which"
" is incremented each time the value stored under a key is updated. The peer "
"that interprets the transaction records all key-value pairs accessed by the "
"chaincode, either for reading or for writing, but the peer does not yet "
"update its state. More specifically:"
msgstr ""
"回想一下，状态由键值对组成。所有键值条目都有版本控制;也就是说，每个条目都包含有序的版本信息，每次更新存储在键下的值时，该信息都会增加。解释交易的peer节点记录链码访问的所有键值对(无论对于读取或写入)，但该peer节点尚未更新其状态。更具体地说:"

#: ../../source/arch-deep-dive.rst:486
msgid ""
"Given state ``s`` before an endorsing peer executes a transaction, for every"
" key ``k`` read by the transaction, pair ``(k,s(k).version)`` is added to "
"``readset``."
msgstr ""
"背书peer节点在执行一个交易之前的给定的状态``s`` ，交易读取的每个键``k`` ，键值对 "
"``(k,s(k).version)``被添加到``readset``。"

#: ../../source/arch-deep-dive.rst:489
msgid ""
"Additionally, for every key ``k`` modified by the transaction to the new "
"value ``v'``, pair ``(k,v')`` is added to ``writeset``. Alternatively, "
"``v'`` could be the delta of the new value to previous value "
"(``s(k).value``)."
msgstr ""
"此外，对于被交易修改为新值到 ``v'``的每个键``k``，键值对``(k,v')``被添加到``writeset``中。或者， "
"``v'``可以是新值与旧值的差值 (``s(k).value``)。"

#: ../../source/arch-deep-dive.rst:494
msgid ""
"If a client specifies ``anchor`` in the ``PROPOSE`` message then client "
"specified ``anchor`` must equal ``readset`` produced by endorsing peer when "
"simulating the transaction."
msgstr "如果客户端在“提议”消息中指定“锚定”，则客户端指定的“锚定”必须等于模拟交易时由背书peer生成的“readset”。"

#: ../../source/arch-deep-dive.rst:498
msgid ""
"Then, the peer forwards internally ``tran-proposal`` (and possibly ``tx``) "
"to the part of its (peer's) logic that endorses a transaction, referred to "
"as **endorsing logic**. By default, endorsing logic at a peer accepts the "
"``tran-proposal`` and simply signs the ``tran-proposal``. However, endorsing"
" logic may interpret arbitrary functionality, to, e.g., interact with legacy"
" systems with ``tran-proposal`` and ``tx`` as inputs to reach the decision "
"whether to endorse a transaction or not."
msgstr ""
"然后，peer节点将内部的“tran-"
"proposal”(可能还有“tx”)转发给它的(peer节点的)背书交易的逻辑部分，称为**背书逻辑**。默认情况下，在peer节点中背书逻辑接受"
"“tran-proposal”，并简单地签署“tran-proposal”。然而，背书逻辑可能会解释任意的功能，例如，使用“trans "
"-proposal”和“tx”做输入与遗留系统交互，来决定是否为交易背书。"

#: ../../source/arch-deep-dive.rst:507
msgid ""
"If endorsing logic decides to endorse a transaction, it sends "
"``<TRANSACTION-ENDORSED, tid, tran-proposal,epSig>`` message to the "
"submitting client(\\ ``tx.clientID``), where:"
msgstr ""
"如果背书逻辑决定背书一个交易，它会向提交客户端(\\ ``tx.clientID``)发送``<TRANSACTION-ENDORSED, tid, "
"tran-proposal,epSig>``消息，其中:"

#: ../../source/arch-deep-dive.rst:511
msgid ""
"``tran-proposal := (epID,tid,chaincodeID,txContentBlob,readset,writeset)``,"
msgstr ""
"``tran-proposal := (epID,tid,chaincodeID,txContentBlob,readset,writeset)``,"

#: ../../source/arch-deep-dive.rst:513
msgid ""
"where ``txContentBlob`` is chaincode/transaction specific information. The "
"intention is to have ``txContentBlob`` used as some representation of ``tx``"
" (e.g., ``txContentBlob=tx.txPayload``)."
msgstr ""
"其中``txContentBlob``'是链码/交易指定信息。其目的是将``txContentBlob``用作 ``tx`` "
"的某种表示形式(例如``txContentBlob=tx.txPayload``)。"

#: ../../source/arch-deep-dive.rst:517
msgid "``epSig`` is the endorsing peer's signature on ``tran-proposal``"
msgstr "“epSig”是背书节点在“tran-proposal”上的签名。"

#: ../../source/arch-deep-dive.rst:519
msgid ""
"Else, in case the endorsing logic refuses to endorse the transaction, an "
"endorser *may* send a message ``(TRANSACTION-INVALID, tid, REJECTED)`` to "
"the submitting client."
msgstr ""
"否则，如果背书逻辑拒绝对交易进行背书，背书者*可以*向提交的客户端发送一条消息``(TRANSACTION-INVALID, tid, "
"REJECTED)`` 。"

#: ../../source/arch-deep-dive.rst:523
msgid ""
"Notice that an endorser does not change its state in this step, the updates "
"produced by transaction simulation in the context of endorsement do not "
"affect the state!"
msgstr "请注意，背书者在此步骤中不会更改其状态，背书上下文中交易模拟生成的更新不会影响状态!"

#: ../../source/arch-deep-dive.rst:528
msgid ""
"2.3. The submitting client collects an endorsement for a transaction and "
"broadcasts it through ordering service"
msgstr "2.3. 提交客户端为交易收集背书并通过排序服务广播"

#: ../../source/arch-deep-dive.rst:530
msgid ""
"The submitting client waits until it receives \"enough\" messages and "
"signatures on ``(TRANSACTION-ENDORSED, tid, *, *)`` statements to conclude "
"that the transaction proposal is endorsed. As discussed in Section 2.1.2., "
"this may involve one or more round-trips of interaction with endorsers."
msgstr ""
"提交客户端等待，直到它收到“足够”的消息和``(TRANSACTION-ENDORSED, tid, *, *)`` "
"语句上的签名，从而断定交易提议已被背书。如第2.1.2节所述，这可能涉及与背书者的一次或多次双向互动。"

#: ../../source/arch-deep-dive.rst:536
msgid ""
"The exact number of \"enough\" depend on the chaincode endorsement policy "
"(see also Section 3). If the endorsement policy is satisfied, the "
"transaction has been *endorsed*; note that it is not yet committed. The "
"collection of signed ``TRANSACTION-ENDORSED`` messages from endorsing peers "
"which establish that a transaction is endorsed is called an *endorsement* "
"and denoted by ``endorsement``."
msgstr ""
"确切数目是否“足够”由链码背书策略而定(另见第3条)。如背书策略符合，则交易已获*背书*；注意，它还没有提交。来自背书节点的已签章“ "
"``TRANSACTION-ENDORSED``消息称为*背书*，并用“背书”表示。"

#: ../../source/arch-deep-dive.rst:543
msgid ""
"If the submitting client does not manage to collect an endorsement for a "
"transaction proposal, it abandons this transaction with an option to retry "
"later."
msgstr "如果提交的客户端未能为交易提议收集到背书，它将放弃该交易，并提供稍后重试的选项。"

#: ../../source/arch-deep-dive.rst:547
msgid ""
"For transaction with a valid endorsement, we now start using the ordering "
"service. The submitting client invokes ordering service using the "
"``broadcast(blob)``, where ``blob=endorsement``. If the client does not have"
" capability of invoking ordering service directly, it may proxy its "
"broadcast through some peer of its choice. Such a peer must be trusted by "
"the client not to remove any message from the ``endorsement`` or otherwise "
"the transaction may be deemed invalid. Notice that, however, a proxy peer "
"may not fabricate a valid ``endorsement``."
msgstr ""
"对于具有有效背书的交易，我们现在开始使用排序服务。提交客户端使用“broadcast(blob)”调用排序服务，其中“blob=背书”。如果客户端没有直接调用排序服务，它可以通过自己选择的某个peer节点代理其广播。客户端必须信任这样的peer节点不会从“背书”中删除任何消息，否则交易可能被视为无效。但是，请注意，代理peer节点不可以伪造有效的“背书”。"

#: ../../source/arch-deep-dive.rst:557
msgid "2.4. The ordering service delivers a transactions to the peers"
msgstr "2.4. 排序服务向peer节点交付交易"

#: ../../source/arch-deep-dive.rst:559
msgid ""
"When an event ``deliver(seqno, prevhash, blob)`` occurs and a peer has "
"applied all state updates for blobs with sequence number lower than "
"``seqno``, a peer does the following:"
msgstr ""
"当一个事件 ``deliver(seqno, prevhash, blob)`` 发生，并且一个peer节点为序号小于 "
"``seqno``的blob应用了所有状态更新时，peer节点执行以下操作:"

#: ../../source/arch-deep-dive.rst:563
msgid ""
"It checks that the ``blob.endorsement`` is valid according to the policy of "
"the chaincode (``blob.tran-proposal.chaincodeID``) to which it refers."
msgstr ""
"它根据所引用的链码(``blob.tran-proposal.chaincodeID``)的策略检查``blob.endorsement``'是有效的。"

#: ../../source/arch-deep-dive.rst:567
msgid ""
"In a typical case, it also verifies that the dependencies "
"(``blob.endorsement.tran-proposal.readset``) have not been violated "
"meanwhile. In more complex use cases, ``tran-proposal`` fields in "
"endorsement may differ and in this case endorsement policy (Section 3) "
"specifies how the state evolves."
msgstr ""
"在典型的情况下，它还验证依赖项(``blob.endorsement.tran-"
"proposal.readset``)没有同时被违反。在更复杂的用例中，背书中的“trans "
"-proposal”字段可能有所不同，在这种情况下，背书策略(第3节)指定状态如何发展。"

#: ../../source/arch-deep-dive.rst:573
msgid ""
"Verification of dependencies can be implemented in different ways, according"
" to a consistency property or \"isolation guarantee\" that is chosen for the"
" state updates. **Serializability** is a default isolation guarantee, unless"
" chaincode endorsement policy specifies a different one. Serializability can"
" be provided by requiring the version associated with *every* key in the "
"``readset`` to be equal to that key's version in the state, and rejecting "
"transactions that do not satisfy this requirement."
msgstr ""
"根据为状态更新选择的一致性属性或“隔离保证”，可以以不同的方式实现依赖项的验证。**Serializability**是默认的隔离保证，除非链码背书策略指定了一个不同的隔离保证。通过要求``readset``中的*每个*键关联的版本等于该键在状态中的版本，提供了Serializability，并拒绝不满足此要求的交易。"

#: ../../source/arch-deep-dive.rst:582
msgid ""
"If all these checks pass, the transaction is deemed *valid* or *committed*. "
"In this case, the peer marks the transaction with 1 in the bitmask of the "
"``PeerLedger``, applies ``blob.endorsement.tran-proposal.writeset`` to "
"blockchain state (if ``tran-proposals`` are the same, otherwise endorsement "
"policy logic defines the function that takes ``blob.endorsement``)."
msgstr ""
"如果所有这些检查通过，交易将被视为“有效”或“已提交”。在本例中，peer节点在“PeerLedger”的比特掩码中使用1标记交易，应用``blob.endorsement"
".tran-proposal.writeset``到区块链状态(如果 ``tran-proposals``相同，否则背书策略逻辑定义接受 "
"``blob.endorsement``的函数)。"

#: ../../source/arch-deep-dive.rst:589
msgid ""
"If the endorsement policy verification of ``blob.endorsement`` fails, the "
"transaction is invalid and the peer marks the transaction with 0 in the "
"bitmask of the ``PeerLedger``. It is important to note that invalid "
"transactions do not change the state."
msgstr ""
"如果背书策略验证``blob.endorsement``失败，交易无效，在``PeerLedger``的比特掩码中，peer节点将交易标记为0。需要注意的是，无效交易不会更改状态。"

#: ../../source/arch-deep-dive.rst:594
msgid ""
"Note that this is sufficient to have all (correct) peers have the same state"
" after processing a deliver event (block) with a given sequence number. "
"Namely, by the guarantees of the ordering service, all correct peers will "
"receive an identical sequence of ``deliver(seqno, prevhash, blob)`` events. "
"As the evaluation of the endorsement policy and evaluation of version "
"dependencies in ``readset`` are deterministic, all correct peers will also "
"come to the same conclusion whether a transaction contained in a blob is "
"valid. Hence, all peers commit and apply the same sequence of transactions "
"and update their state in the same way."
msgstr ""
"注意，在使用给定的序列号处理一个交付事件(区块)之后，所有(正确的)peer节点都具有相同的状态就足够了。也就是说，通过排序服务的保证，所有正确的peer节点将接收相同的``deliver(seqno,"
" prevhash, "
"blob)``事件序列。由于对背书策略的评估和对“readset”中的版本依赖关系的评估是确定的，所以所有正确的peer节点也会得出相同的结论，即blob中包含的交易是否有效。因此，所有peer节点提交和应用相同的交易序列，并以相同的方式更新它们的状态。"

#: ../../source/arch-deep-dive.rst:610
msgid ""
"*Figure 1. Illustration of one possible transaction flow (common-case "
"path).*"
msgstr "*图1 . 说明一种可能的交易流程(常见情况路径)。*"

#: ../../source/arch-deep-dive.rst:613
msgid "3. Endorsement policies"
msgstr "3. 背书策略"

#: ../../source/arch-deep-dive.rst:616
msgid "3.1. Endorsement policy specification"
msgstr "3.1. 背书策略规范"

#: ../../source/arch-deep-dive.rst:618
msgid ""
"An **endorsement policy**, is a condition on what *endorses* a transaction. "
"Blockchain peers have a pre-specified set of endorsement policies, which are"
" referenced by a ``deploy`` transaction that installs specific chaincode. "
"Endorsement policies can be parametrized, and these parameters can be "
"specified by a ``deploy`` transaction."
msgstr ""
"**背书策略**是*背书*交易的条件。区块链peer节点有一组预先指定的背书策略，这些策略由安装特定链码的 "
"``部署``交易引用。背书策略可以参数化，这些参数可以通过“部署”交易指定。"

#: ../../source/arch-deep-dive.rst:624
msgid ""
"To guarantee blockchain and security properties, the set of endorsement "
"policies **should be a set of proven policies** with limited set of "
"functions in order to ensure bounded execution time (termination), "
"determinism, performance and security guarantees."
msgstr ""
"为了保证区块链和安全性属性，背书策略集**应该是一组经过验证的策略**，具有有限的函数集，以确保有限的执行时间(终止)、确定性、性能和安全性保证。"

#: ../../source/arch-deep-dive.rst:629
msgid ""
"Dynamic addition of endorsement policies (e.g., by ``deploy`` transaction on"
" chaincode deploy time) is very sensitive in terms of bounded policy "
"evaluation time (termination), determinism, performance and security "
"guarantees. Therefore, dynamic addition of endorsement policies is not "
"allowed, but can be supported in future."
msgstr ""
"在有限的策略评估时间(终止)、确定性、性能和安全性保证方面，背书策略的动态添加(例如通过链码部署时的“部署”交易)非常敏感。因此，背书策略的动态添加是不允许的，但可以在将来支持。"

#: ../../source/arch-deep-dive.rst:636
msgid "3.2. Transaction evaluation against endorsement policy"
msgstr "3.2. 根据背书策略进行交易评估"

#: ../../source/arch-deep-dive.rst:638
msgid ""
"A transaction is declared valid only if it has been endorsed according to "
"the policy. An invoke transaction for a chaincode will first have to obtain "
"an *endorsement* that satisfies the chaincode's policy or it will not be "
"committed. This takes place through the interaction between the submitting "
"client and endorsing peers as explained in Section 2."
msgstr ""
"只有根据策略进行了背书，交易才被声明为有效。链码的调用交易首先必须获得一个满足链码策略的*背书*，否则不会提交。这是通过提交客户端和背书节点之间的交互来实现的，如第2节所述。"

#: ../../source/arch-deep-dive.rst:644
msgid ""
"Formally the endorsement policy is a predicate on the endorsement, and "
"potentially further state that evaluates to TRUE or FALSE. For deploy "
"transactions the endorsement is obtained according to a system-wide policy "
"(for example, from the system chaincode)."
msgstr ""
"形式上，背书策略是对背书的断言，并且可能是其计算结果为TRUE或FALSE的进一步的状态。对于部署交易，背书是根据系统范围的策略(例如从系统链码)获得的。"

#: ../../source/arch-deep-dive.rst:649
msgid ""
"An endorsement policy predicate refers to certain variables. Potentially it "
"may refer to:"
msgstr "背书策略断言引用某些变量。可能是指:"

#: ../../source/arch-deep-dive.rst:652
msgid ""
"keys or identities relating to the chaincode (found in the metadata of the "
"chaincode), for example, a set of endorsers;"
msgstr "与链码相关的键或标识(可在链码元数据中找到)，例如，一组背书器;"

#: ../../source/arch-deep-dive.rst:654
msgid "further metadata of the chaincode;"
msgstr "链码的进一步元数据;"

#: ../../source/arch-deep-dive.rst:655
msgid "elements of the ``endorsement`` and ``endorsement.tran-proposal``;"
msgstr "“endorsement”和``endorsement.tran-proposal``的元素;"

#: ../../source/arch-deep-dive.rst:656
msgid "and potentially more."
msgstr "并且可能更多。"

#: ../../source/arch-deep-dive.rst:658
msgid ""
"The above list is ordered by increasing expressiveness and complexity, that "
"is, it will be relatively simple to support policies that only refer to keys"
" and identities of nodes."
msgstr "上面的列表是通过渐增的表达性和复杂性来排序的，也就是说，支持只引用node节点的键和身份的策略将相对简单。"

#: ../../source/arch-deep-dive.rst:662
msgid ""
"**The evaluation of an endorsement policy predicate must be deterministic.**"
" An endorsement shall be evaluated locally by every peer such that a peer "
"does *not* need to interact with other peers, yet all correct peers evaluate"
" the endorsement policy in the same way."
msgstr ""
"背书策略断言的计算必须是确定的。**背书应由每一个peer节点在本地进行评估，以便该peer节点不需要与其他节点进行交互，但所有正直的peer节点对背书策略的评估是相同的。"

#: ../../source/arch-deep-dive.rst:668
msgid "3.3. Example endorsement policies"
msgstr "3.3. 背书策略的例子"

#: ../../source/arch-deep-dive.rst:670
msgid ""
"The predicate may contain logical expressions and evaluates to TRUE or "
"FALSE. Typically the condition will use digital signatures on the "
"transaction invocation issued by endorsing peers for the chaincode."
msgstr "断言可以包含逻辑表达式，并且计算为TRUE或FALSE。通常情况下，该条件将在交易调用上使用数字签名，签名由为链码背书的peer节点签发。"

#: ../../source/arch-deep-dive.rst:674
msgid ""
"Suppose the chaincode specifies the endorser set ``E = {Alice, Bob, Charlie,"
" Dave, Eve, Frank, George}``. Some example policies:"
msgstr ""
"假设链码指定背书集合 ``E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}``。一些示例策略:"

#: ../../source/arch-deep-dive.rst:678
msgid ""
"A valid signature from on the same ``tran-proposal`` from all members of E."
msgstr "E所有成员在相同``tran-proposal`` 上的一个有效签名。"

#: ../../source/arch-deep-dive.rst:681
msgid "A valid signature from any single member of E."
msgstr "E的任何一个成员的有效签名。"

#: ../../source/arch-deep-dive.rst:683
msgid ""
"Valid signatures on the same ``tran-proposal`` from endorsing peers "
"according to the condition ``(Alice OR Bob) AND (any two of: Charlie, Dave, "
"Eve, Frank, George)``."
msgstr ""
"根据条件``(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, "
"George)``，在相同``tran-proposal``上来自背书节点的有效签名。"

#: ../../source/arch-deep-dive.rst:687
msgid ""
"Valid signatures on the same ``tran-proposal`` by any 5 out of the 7 "
"endorsers. (More generally, for chaincode with ``n > 3f`` endorsers, valid "
"signatures by any ``2f+1`` out of the ``n`` endorsers, or by any group of "
"*more* than ``(n+f)/2`` endorsers.)"
msgstr ""
"七名背书者中的五名在同一份``tran-proposal`` 上的有效签名。(更一般地说，对于具有``n > "
"3f``个背书者的链码，由``n``背书者中的任意``2f+1``个进行有效签名，或由多于``(n+f)/2``个背书者组成的任何组合进行有效签名。)"

#: ../../source/arch-deep-dive.rst:692
msgid ""
"Suppose there is an assignment of \"stake\" or \"weights\" to the endorsers,"
" like ``{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}``,"
" where the total stake is 100: The policy requires valid signatures from a "
"set that has a majority of the stake (i.e., a group with combined stake "
"strictly more than 50), such as ``{Alice, X}`` with any ``X`` different from"
" George, or ``{everyone together except Alice}``. And so on."
msgstr ""
"假设有一个“股份”或“权重”分配给背书者，如 ``{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, "
"Frank=3, "
"George=1}``，其中总股份为100：该策略要求的有效签名来自大多数股份的集合（例如组合股份严格大于50的组合），例如，``{Alice, "
"X}`` ，X不能是George，或 ``{出了Alice的全体组合在一起}``。等等。"

#: ../../source/arch-deep-dive.rst:701
msgid ""
"The assignment of stake in the previous example condition could be static "
"(fixed in the metadata of the chaincode) or dynamic (e.g., dependent on the "
"state of the chaincode and be modified during the execution)."
msgstr "在前面的示例条件中，股份的分配可以是静态的(在链码的元数据中固定)，也可以是动态的(例如，取决于链码的状态，并在执行过程中进行修改)。"

#: ../../source/arch-deep-dive.rst:706
msgid ""
"Valid signatures from (Alice OR Bob) on ``tran-proposal1`` and valid "
"signatures from ``(any two of: Charlie, Dave, Eve, Frank, George)`` on "
"``tran-proposal2``, where ``tran-proposal1`` and ``tran-proposal2`` differ "
"only in their endorsing peers and state updates."
msgstr ""
"(Alice或Bob)在“tran-proposal1”上的有效签名，以及在“tran-"
"proposal2”上的有效签名(查理、戴夫、伊芙、弗兰克、乔治中的任意两人)，其中“tran-proposal1”和“tran-"
"proposal2”的有效签名仅在背书节点和状态更新上存在差异。"

#: ../../source/arch-deep-dive.rst:712
msgid ""
"How useful these policies are will depend on the application, on the desired"
" resilience of the solution against failures or misbehavior of endorsers, "
"and on various other properties."
msgstr "这些策略的有用程度将取决于应用程序、解决方案对背书者的失败或不当行为的预期弹性，以及各种其他属性。"

#: ../../source/arch-deep-dive.rst:717
msgid ""
"4 (post-v1). Validated ledger and ``PeerLedger`` checkpointing (pruning)"
msgstr "4 (post-v1). 验证账本和“PeerLedger”检查点(修剪)"

#: ../../source/arch-deep-dive.rst:720
msgid "4.1. Validated ledger (VLedger)"
msgstr "4.1. 已验证账本 (VLedger)"

#: ../../source/arch-deep-dive.rst:722
msgid ""
"To maintain the abstraction of a ledger that contains only valid and "
"committed transactions (that appears in Bitcoin, for example), peers may, in"
" addition to state and Ledger, maintain the *Validated Ledger (or VLedger)*."
" This is a hash chain derived from the ledger by filtering out invalid "
"transactions."
msgstr ""
"为了维护只包含有效和已提交交易（例如比特币的作法）的账本抽象，peer节点可以在状态和账本之外维护*已验证(或VLedger)*。这是从账本中过滤掉无效交易而得到的哈希链。"

#: ../../source/arch-deep-dive.rst:728
msgid ""
"The construction of the VLedger blocks (called here *vBlocks*) proceeds as "
"follows. As the ``PeerLedger`` blocks may contain invalid transactions "
"(i.e., transactions with invalid endorsement or with invalid version "
"dependencies), such transactions are filtered out by peers before a "
"transaction from a block becomes added to a vBlock. Every peer does this by "
"itself (e.g., by using the bitmask associated with ``PeerLedger``). A vBlock"
" is defined as a block without the invalid transactions, that have been "
"filtered out. Such vBlocks are inherently dynamic in size and may be empty. "
"An illustration of vBlock construction is given in the figure below."
msgstr ""
"VLedger区块(这里称为*vBlocks*)的构建过程如下。因为“PeerLedger”区块可能包含无效的交易（例如具有无效背书或无效版本依赖项的交易)，在将来自区块的交易添加到vBlock之前，peer节点将筛选掉此类交易。每个peer节点都自己做这件事(例如，使用与``PeerLedger``关联的比特掩码)。vBlock被定义为一个不含无效交易的区块，无效交易被过滤掉了。这样的vblock在大小上是动态的，可能是空的。下图给出了vBlock构造的一个例子。"

#: ../../source/arch-deep-dive.rst:742
msgid ""
"*Figure 2. Illustration of validated ledger block (vBlock) formation from "
"ledger (PeerLedger) blocks.*"
msgstr "*图2. 从账本(PeerLedger)区块中生成已验证区块(vBlock)的图解。*"

#: ../../source/arch-deep-dive.rst:744
msgid ""
"vBlocks are chained together to a hash chain by every peer. More "
"specifically, every block of a validated ledger contains:"
msgstr "每个peer节点都将vBlocks链接到一个哈希链上。更具体地说，每一个已验证账本包含:"

#: ../../source/arch-deep-dive.rst:747
msgid "The hash of the previous vBlock."
msgstr "前一个vBlock的哈希值。"

#: ../../source/arch-deep-dive.rst:749
msgid "vBlock number."
msgstr "vBlock号码。"

#: ../../source/arch-deep-dive.rst:751
msgid ""
"An ordered list of all valid transactions committed by the peers since the "
"last vBlock was computed (i.e., list of valid transactions in a "
"corresponding block)."
msgstr "自最后一个vBlock被计算以来，peer节点提交的所有有效交易的有序列表(即相应区块中的有效交易列表)。"

#: ../../source/arch-deep-dive.rst:755
msgid ""
"The hash of the corresponding block (in ``PeerLedger``) from which the "
"current vBlock is derived."
msgstr "对应区块的哈希值(在``PeerLedger``中)，当前vBlock就是从中派生出来的。"

#: ../../source/arch-deep-dive.rst:758
msgid ""
"All this information is concatenated and hashed by a peer, producing the "
"hash of the vBlock in the validated ledger."
msgstr "所有这些信息都由一个peer节点连接和哈希，在已验证账本中生成vBlock的哈希。"

#: ../../source/arch-deep-dive.rst:762
msgid "4.2. ``PeerLedger`` Checkpointing"
msgstr "4.2. ``PeerLedger`` 检查点"

#: ../../source/arch-deep-dive.rst:764
msgid ""
"The ledger contains invalid transactions, which may not necessarily be "
"recorded forever. However, peers cannot simply discard ``PeerLedger`` blocks"
" and thereby prune ``PeerLedger`` once they establish the corresponding "
"vBlocks. Namely, in this case, if a new peer joins the network, other peers "
"could not transfer the discarded blocks (pertaining to ``PeerLedger``) to "
"the joining peer, nor convince the joining peer of the validity of their "
"vBlocks."
msgstr ""
"账本包含无效的交易，不一定要永远记录。然而，peer节点不能简单地丢弃``PeerLedger``区块，从而在他们建立了相应的vBlocks之后修剪``PeerLedger``。也就是说，在这种情况下，如果一个新的peer节点加入网络，其他peer节点不能将丢弃的区块(属于“PeerLedger”)转移到加入的peer节点，也不能说服加入的peer节点他们的vBlock的有效性。"

#: ../../source/arch-deep-dive.rst:772
msgid ""
"To facilitate pruning of the ``PeerLedger``, this document describes a "
"*checkpointing* mechanism. This mechanism establishes the validity of the "
"vBlocks across the peer network and allows checkpointed vBlocks to replace "
"the discarded ``PeerLedger`` blocks. This, in turn, reduces storage space, "
"as there is no need to store invalid transactions. It also reduces the work "
"to reconstruct the state for new peers that join the network (as they do not"
" need to establish validity of individual transactions when reconstructing "
"the state by replaying ``PeerLedger``, but may simply replay the state "
"updates contained in the validated ledger)."
msgstr ""
"为了方便修剪``PeerLedger``，本文档描述了一个*检查点*机制。该机制建立了跨peer网络的vBlock的有效性，并允许检查点vBlock替换被丢弃的``PeerLedger``区块。这进而减少了存储空间，因为不需要存储无效的交易。它还减少了为加入网络的新peer节点重构状态的工作(因为当通过重放``PeerLedger``来重构状态时，它们不需要建立单个交易的有效性，而只需重放已验证账本中包含的状态更新)。"

#: ../../source/arch-deep-dive.rst:784
msgid "4.2.1. Checkpointing protocol"
msgstr "4.2.1. 检查点协议"

#: ../../source/arch-deep-dive.rst:786
msgid ""
"Checkpointing is performed periodically by the peers every *CHK* blocks, "
"where *CHK* is a configurable parameter. To initiate a checkpoint, the peers"
" broadcast (e.g., gossip) to other peers message "
"``<CHECKPOINT,blocknohash,blockno,stateHash,peerSig>``, where ``blockno`` is"
" the current blocknumber and ``blocknohash`` is its respective hash, "
"``stateHash`` is the hash of the latest state (produced by e.g., a Merkle "
"hash) upon validation of block ``blockno`` and ``peerSig`` is peer's "
"signature on ``(CHECKPOINT,blocknohash,blockno,stateHash)``, referring to "
"the validated ledger."
msgstr ""
"每个*CHK*区块的peer节点定期执行检查点，其中*CHK*是一个可配置参数。为了发起一个检查点，peer节点广播(例如gossip)消息``<CHECKPOINT,blocknohash,blockno,stateHash,peerSig>``到其它peer节点,"
" 其中``blockno`` "
"是当前区块号和“blocknohash“是其各自的哈希,“stateHash“是根据区块的``blockno``验证的最新状态的哈希(例如,产生自Merkle哈希)，``peerSig``peer节点在``(CHECKPOINT,blocknohash,blockno,stateHash)``的签名，指的是已验证账本。"

#: ../../source/arch-deep-dive.rst:797
msgid ""
"A peer collects ``CHECKPOINT`` messages until it obtains enough correctly "
"signed messages with matching ``blockno``, ``blocknohash`` and ``stateHash``"
" to establish a *valid checkpoint* (see Section 4.2.2.)."
msgstr ""
"一个peer节点收集``CHECKPOINT``消息，直到它获得与``blockno``、``blocknohash`` 和``stateHash`` "
"匹配的足够正确签名的消息，以建立一个*有效的检查点*(参见4.2.2.)。"

#: ../../source/arch-deep-dive.rst:801
msgid ""
"Upon establishing a valid checkpoint for block number ``blockno`` with "
"``blocknohash``, a peer:"
msgstr "在为区块号``blockno`` 和``blocknohash``建立一个有效的检查点时，一个peer节点:"

#: ../../source/arch-deep-dive.rst:804
msgid ""
"if ``blockno>latestValidCheckpoint.blockno``, then a peer assigns "
"``latestValidCheckpoint=(blocknohash,blockno)``,"
msgstr ""
"如果 ``blockno>latestValidCheckpoint.blockno``，则peer赋值 "
"``latestValidCheckpoint=(blocknohash,blockno)``,"

#: ../../source/arch-deep-dive.rst:806
msgid ""
"stores the set of respective peer signatures that constitute a valid "
"checkpoint into the set ``latestValidCheckpointProof``,"
msgstr "将构成有效检查点的各peer节点签名集合存储到集合``latestValidCheckpointProof``中，"

#: ../../source/arch-deep-dive.rst:808
msgid ""
"stores the state corresponding to ``stateHash`` to "
"``latestValidCheckpointedState``,"
msgstr "存储与 ``stateHash``对应的状态到``latestValidCheckpointedState``,"

#: ../../source/arch-deep-dive.rst:810
msgid ""
"(optionally) prunes its ``PeerLedger`` up to block number ``blockno`` "
"(inclusive)."
msgstr "(可选)修剪它的“PeerLedger”“到区块号“blockno”(包括)。"

#: ../../source/arch-deep-dive.rst:814
msgid "4.2.2. Valid checkpoints"
msgstr "4.2.2. 有效的检查点"

#: ../../source/arch-deep-dive.rst:816
msgid ""
"Clearly, the checkpointing protocol raises the following questions: *When "
"can a peer prune its ``PeerLedger``? How many ``CHECKPOINT`` messages are "
"\"sufficiently many\"?*. This is defined by a *checkpoint validity policy*, "
"with (at least) two possible approaches, which may also be combined:"
msgstr ""
"显然，检查点协议提出了以下问题:*peer节点何时可以删除其“PeerLedger”?有多少“检查点”消息是“足够多的”?*。这是由一个*检查点有效性策略*定义的，有(至少)两种可能的方法，也可以组合使用:"

#: ../../source/arch-deep-dive.rst:822
msgid ""
"*Local (peer-specific) checkpoint validity policy (LCVP).* A local policy at"
" a given peer *p* may specify a set of peers which peer *p* trusts and whose"
" ``CHECKPOINT`` messages are sufficient to establish a valid checkpoint. For"
" example, LCVP at peer *Alice* may define that *Alice* needs to receive "
"``CHECKPOINT`` message from Bob, or from *both* *Charlie* and *Dave*."
msgstr ""
"*本地(特定于peer节点)检查点有效性策略(LCVP)。*一个给定peer节点*p*的本地策略可以指定节点*p*信任的一组peer节点，并且它们的“CHECKPOINT”消息足以建立有效的检查点。例如，节点*Alice*的LCVP可能定义*Alice*需要从Bob、或同时从*Charlie*和*Dave*接收“CHECKPOINT”消息。"

#: ../../source/arch-deep-dive.rst:829
msgid ""
"*Global checkpoint validity policy (GCVP).* A checkpoint validity policy may"
" be specified globally. This is similar to a local peer policy, except that "
"it is stipulated at the system (blockchain) granularity, rather than peer "
"granularity. For instance, GCVP may specify that:"
msgstr ""
"*全局检查点有效性策略(GCVP)。可以全局指定检查点有效性策略。这类似于本地peer节点策略，只是它是在系统粒度(区块链)而不是peer节点粒度中规定的。例如，GCVP可以指定:"

#: ../../source/arch-deep-dive.rst:835
msgid "each peer may trust a checkpoint if confirmed by *11* different peers."
msgstr "如果得到*11*个不同的peer节点确认，每个peer节点都可以信任这个检查点。"

#: ../../source/arch-deep-dive.rst:837
msgid ""
"in a specific deployment in which every orderer is collocated with a peer in"
" the same machine (i.e., trust domain) and where up to *f* orderers may be "
"(Byzantine) faulty, each peer may trust a checkpoint if confirmed by *f+1* "
"different peers collocated with orderers."
msgstr ""
"在特定的部署中，每个排序器都在同一台机器中（即信任域）搭配了一个peer节点，即当多达*f* "
"个排序器可能(拜占庭式的)错误时，如果由*f+1*与排序器一起配置的不同peer节点确认，每个peer节点都可以信任检查点。"
