# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# JulienGuo郭立冬 <690748277@qq.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-01 12:09+0800\n"
"PO-Revision-Date: 2019-04-22 19:57+0000\n"
"Last-Translator: JulienGuo郭立冬 <690748277@qq.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/hyperledger/teams/97220/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/endorsement-policies.rst:2
msgid "Endorsement policies"
msgstr "背书策略"

#: ../../source/endorsement-policies.rst:4
msgid ""
"Every chaincode has an endorsement policy which specifies the set of peers "
"on a channel that must execute chaincode and endorse the execution results "
"in order for the transaction to be considered valid. These endorsement "
"policies define the organizations (through their peers) who must \"endorse\""
" (i.e., approve of) the execution of a proposal."
msgstr ""
"每个链码都有一个背书策略，该策略指定通道上的一组Peers，这些Peers必须执行链码并给执行结果背书，以使得交易被认为是有效的。这些背书策略定义了必须为交易提案执行\"背书\"的组织（组织通过他们的Peers具体执行）。"

#: ../../source/endorsement-policies.rst:10
msgid ""
"Recall that **state**, represented by key-value pairs, is separate from "
"blockchain data. For more on this, check out our :doc:`ledger/ledger` "
"documentation."
msgstr ""
"回想一下，由键值对表示的**state**与区块链数据是分开的。有关更多信息，请查看我们的 :doc:`ledger/ledger` 文档。"

#: ../../source/endorsement-policies.rst:14
msgid ""
"As part of the transaction validation step performed by the peers, each "
"validating peer checks to make sure that the transaction contains the "
"appropriate **number** of endorsements and that they are from the expected "
"sources (both of these are specified in the endorsement policy). The "
"endorsements are also checked to make sure they're valid (i.e., that they "
"are valid signatures from valid certificates)."
msgstr ""
"作为Peers执行的交易验证步骤的一部分，每个验证Peer都要检查交易所包含的背书数量，保证该数量满足要求的**number**，并且还要确保每个背书来自预期的执行节点（数量和执行节点都在背书策略中指定）。背书本身也会被检查，以确保它们是有效的（有效背书是指由有效证书执行的有效签名)。"

#: ../../source/endorsement-policies.rst:21
msgid "Two ways to require endorsement"
msgstr "获取背书的两个方法"

#: ../../source/endorsement-policies.rst:23
msgid ""
"By default, endorsement policies are specified in the chaincode definition, "
"which is agreed to by channel members and then committed to a channel (that "
"is, one endorsement policy covers all of the state associated with a "
"chaincode)."
msgstr "默认情况下，背书策略是在链码定义中指定的，该定义得到通道成员的同意，然后提交给通道(即，一个背书策略覆盖与该链码关联的所有状态)。"

#: ../../source/endorsement-policies.rst:27
msgid ""
"However, there are cases where it may be necessary for a particular state (a"
" particular key-value pair, in other words) to have a different endorsement "
"policy. This **state-based endorsement** allows the default chaincode-level "
"endorsement policies to be overridden by a different policy for the "
"specified keys."
msgstr ""
"但是，在某些情况下，特定的state（换句话说，特定的键值对）可能需要使用不同的背书策略。这个基于状态的背书**state-based "
"endorsement**允许对指定键使用不同的策略覆盖默认的链码级别的背书策略。"

#: ../../source/endorsement-policies.rst:32
msgid ""
"To illustrate the circumstances in which these two types of endorsement "
"policies might be used, consider a channel on which cars are being "
"exchanged. The \"creation\" --- also known as \"issuance\" -- of a car as an"
" asset that can be traded (putting the key-value pair that represents it "
"into the world state, in other words) would have to satisfy the chaincode-"
"level endorsement policy. To see how to set a chaincode-level endorsement "
"policy, check out the section below."
msgstr ""
"为了说明在何种情况下可以使用这两种类型的背书政策，请考虑车辆交易的通道（官方examples之一）。汽车作为一种可交易资产，它的\"creation创建\""
"--也称为 "
"\"issuance发行\"--（换句话说，将代表它的键值对放入世界状态）将必须满足链码级的背书策略。要查看如何设置链码级背书策略，请查看下面的部分。"

#: ../../source/endorsement-policies.rst:39
msgid ""
"If the car requires a specific endorsement policy, it can be defined either "
"when the car is created or afterwards. There are a number of reasons why it "
"might be necessary or preferable to set a state-specific endorsement policy."
" The car might have historical importance or value that makes it necessary "
"to have the endorsement of a licensed appraiser. Also, the owner of the car "
"(if they're a member of the channel) might also want to ensure that their "
"peer signs off on a transaction. In both cases, **an endorsement policy is "
"required for a particular asset that is different from the default "
"endorsement policies for the other assets associated with that chaincode.**"
msgstr ""
"如果汽车需要特定的背书策略，则可以在创建汽车时或之后定义该策略。有许多理由可以说明为什么有必要或更可取地制定与特定state相关的背书策略。该车可能具有历史重要性或价值，因此有必要获得持牌估价师的认可。此外，汽车的拥有者（如果他们是通道的成员）可能还希望确保他们的Peer在交易上签名。在这两种情况下，**都需要对特定的资产使用特定的背书策略，该策略不同于与链码关联的其他资产的默认背书策略。**"

#: ../../source/endorsement-policies.rst:49
msgid ""
"We'll show you how to define a state-based endorsement policy in a "
"subsequent section. But first, let's see how we set a chaincode-level "
"endorsement policy."
msgstr "我们将在下一节中介绍如何定义基于状态的背书策略。但首先，让我们看看如何设置链码级的背书策略。"

#: ../../source/endorsement-policies.rst:53
msgid "Setting chaincode-level endorsement policies"
msgstr "设置链码级的背书策略"

#: ../../source/endorsement-policies.rst:55
msgid ""
"Chaincode-level endorsement policies are agreed to by channel members when "
"they approve a chaincode definition for their organization. A sufficient "
"number of channel members need to approve a chaincode definition to meet the"
" ``Channel/Application/LifecycleEndorsement`` policy, which by default is "
"set to a majority of channel members, before the definition can be committed"
" to the channel. Once the definition has been committed, the chaincode is "
"ready to use. Any invoke of the chaincode that writes data to the ledger "
"will need to be validated by enough channel members to meet the endorsement "
"policy."
msgstr ""
"链码级背书策略是由通道成员在为其组织批准链码定义时同意的。需要足够多的通道成员批准链码定义，以满足``Channel/Application/LifecycleEndorsement``策略，该策略默认设置为多数通道成员批准定义，才能将定义提交给通道。一旦提交了定义，链码就可以使用了。任何向账本写入数据的链码调用都需要经过足够多的通道成员的验证，以满足背书策略。"

#: ../../source/endorsement-policies.rst:64
msgid ""
"You can specify an endorsement policy for a chainocode using the Fabric "
"SDKs. For an example, visit the `How to install and start your chaincode "
"<https://fabric-sdk-node.github.io/master/tutorial-chaincode-"
"lifecycle.html>`_ in the Node.js SDK documentation. You can also create an "
"endorsement policy from your CLI when you approve and commit a chaincode "
"definition with the Fabric peer binaries by using the ``—-signature-policy``"
" flag."
msgstr ""
"你可以使用Fabric SDKs为链码指定背书策略。例如，访问Node.js SDK文档的页面 `How to install and start "
"your chaincode <https://fabric-sdk-node.github.io/master/tutorial-chaincode-"
"lifecycle.html>`_ 。当你在Fabric peer环境下批准并且提交链码定义时，你还可以从CLI创建背书策略，使用flag"
"``—-signature-policy``指定。"

#: ../../source/endorsement-policies.rst:70
msgid ""
"Don't worry about the policy syntax (``'Org1.member'``, et all) right now. "
"We'll talk more about the syntax in the next section."
msgstr "暂时不要担心策略语法（类似``'Org1.member'``）。我们将在下一节详细讨论语法。"

#: ../../source/endorsement-policies.rst:73
#: ../../source/endorsement-policies.rst:92
#: ../../source/endorsement-policies.rst:104
#: ../../source/endorsement-policies.rst:163
msgid "For example:"
msgstr "例如："

#: ../../source/endorsement-policies.rst:79
msgid ""
"The above command approves the chaincode definition of ``mycc`` with the "
"policy ``AND('Org1.member', 'Org2.member')`` which would require that a "
"member of both Org1 and Org2 sign the transaction. After a sufficient number"
" of channel members approve a chaincode definition for ``mycc``, the "
"definition and endorsement policy can be committed to the channel using the "
"command below:"
msgstr ""
"上面的命令使用策略``AND('Org1.member', "
"'Org2.member')``来批准``mycc``的链码定义，这个策略要求Org1和Org2的成员都签署交易。在足够多的通道成员批准``mycc``的链码定义后，可使用以下命令将定义和背书策略提交给通道："

#: ../../source/endorsement-policies.rst:89
msgid ""
"Notice that, if the identity classification is enabled (see :doc:`msp`), one"
" can use the ``PEER`` role to restrict endorsement to only peers."
msgstr "请注意，如果启用了标识分类 （查看 :doc:`msp`），则可以使用``PEER``角色将背书限制为仅对Peers有效。"

#: ../../source/endorsement-policies.rst:99
msgid ""
"In addition to the specifying an endorsement policy from the CLI or SDK, a "
"chaincode can also use policies in the channel configuration as endorsement "
"policies. You can use the ``--channel-config-policy``flag to select a "
"channel policy with format used by the channel configuration and by ACLs."
msgstr ""
"除了从CLI或SDK指定背书策略外，链码还可以使用通道配置中的策略作为背书策略。您可以使用 ``--channel-config-"
"policy``标记选择一个通道策略，格式按照使用通道配置和ACLs的方式。"

#: ../../source/endorsement-policies.rst:110
msgid ""
"If you do not specify a policy, the chaincode definition will use the "
"``Channel/Application/Endorsement`` policy by default, which requires that a"
" transaction be validated by a majority of channel members. This policy "
"depends on the membership of the channel, so it will be updated "
"automatically when organizations are added or removed from a channel. One "
"advantage of using channel policies is that they can be written to be "
"updated automatically with channel membership."
msgstr ""
"如果你不指定策略，链码定义会默认使用策略``Channel/Application/Endorsement``，这个策略要求交易被通道中的多数成员验证。这个策略依赖通道的成员关系，所以当通道中添加组织或者删除组织的时候，策略将会自动更新。"

#: ../../source/endorsement-policies.rst:117
msgid ""
"If you specify an endorsement policy using the ``—-signature-policy`` flag "
"or the SDK, you will need to update the policy when organizations join or "
"leave the channel. A new organization added to the channel after "
"instantiation will be able to query a chaincode (provided the query has "
"appropriate authorization as defined by channel policies and any application"
" level checks enforced by the chaincode) but will not be able to execute or "
"endorse the chaincode. Only organizations listed in the endorsement policy "
"syntax will be able sign transactions."
msgstr ""
"如果使用``—-signature-"
"policy``标志或SDK指定背书策略，则需要在组织加入或离开通道时更新策略。链码实例化后添加到通道的新组织能够查询链码（查询要具有通道策略定义的适当授权，和链码强制执行的应用程序级别检查），但不能执行或背书链码。只有在背书策略语法中列出的组织才能签署交易。"

#: ../../source/endorsement-policies.rst:127
msgid "Endorsement policy syntax"
msgstr "背书策略语法"

#: ../../source/endorsement-policies.rst:129
msgid ""
"As you can see above, policies are expressed in terms of principals "
"(\"principals\" are identities matched to a role). Principals are described "
"as ``'MSP.ROLE'``, where ``MSP`` represents the required MSP ID and ``ROLE``"
" represents one of the four accepted roles: ``member``, ``admin``, "
"``client``, and ``peer``."
msgstr ""
"正如您在上面看到的，策略是以主体（\"主体\"是与角色匹配的身份）表示的。主体被描述为``'MSP.ROLE'``，其中``MSP``表示所需的MSP "
"ID， ``ROLE`` 表示四个可接受的角色之一：``member``、``admin``、``client``和 ``peer``。"

#: ../../source/endorsement-policies.rst:135
msgid "Here are a few examples of valid principals:"
msgstr "以下是一些有效主体的例子："

#: ../../source/endorsement-policies.rst:137
msgid "``'Org0.admin'``: any administrator of the ``Org0`` MSP"
msgstr "``'Org0.admin'``：``Org0`` MSP的任何管理员"

#: ../../source/endorsement-policies.rst:138
msgid "``'Org1.member'``: any member of the ``Org1`` MSP"
msgstr "``'Org1.member'``：``Org1`` MSP的任何成员"

#: ../../source/endorsement-policies.rst:139
msgid "``'Org1.client'``: any client of the ``Org1`` MSP"
msgstr "``'Org1.client'``：``Org1`` MSP的任何客户端"

#: ../../source/endorsement-policies.rst:140
msgid "``'Org1.peer'``: any peer of the ``Org1`` MSP"
msgstr "``'Org1.peer'``：``Org1`` MSP的任何Peer"

#: ../../source/endorsement-policies.rst:142
msgid "The syntax of the language is:"
msgstr "语言的语法是："

#: ../../source/endorsement-policies.rst:144
msgid "``EXPR(E[, E...])``"
msgstr "``EXPR(E[, E...])``"

#: ../../source/endorsement-policies.rst:146
msgid ""
"Where ``EXPR`` is either ``AND``, ``OR``, or ``OutOf``, and ``E`` is either "
"a principal (with the syntax described above) or another nested call to "
"``EXPR``."
msgstr ""
"``EXPR``是``AND``、``OR``、``OutOf``三者中的一个，``E``是一个主体（上面所述的语法所指）或者一个嵌套调用的``EXPR``。"

#: ../../source/endorsement-policies.rst:150
msgid ""
"``AND('Org1.member', 'Org2.member', 'Org3.member')`` requests one signature "
"from each of the three principals."
msgstr ""
"``AND('Org1.member', 'Org2.member', 'Org3.member')`` 要求三个主体每一个都给出一个签名。"

#: ../../source/endorsement-policies.rst:152
msgid ""
"``OR('Org1.member', 'Org2.member')`` requests one signature from either one "
"of the two principals."
msgstr "``OR('Org1.member', 'Org2.member')``要求两个主体中至少有一个给出签名。"

#: ../../source/endorsement-policies.rst:154
msgid ""
"``OR('Org1.member', AND('Org2.member', 'Org3.member'))`` requests either one"
" signature from a member of the ``Org1`` MSP or one signature from a member "
"of the ``Org2`` MSP and one signature from a member of the ``Org3`` MSP."
msgstr ""
"``OR('Org1.member', AND('Org2.member', 'Org3.member'))``要求一个来自于`Org1`` "
"MSP成员的签名，或者一个来自于``Org2`` MSP成员的签名和一个来自于``Org3`` MSP成员的签名。"

#: ../../source/endorsement-policies.rst:157
msgid ""
"``OutOf(1, 'Org1.member', 'Org2.member')``, which resolves to the same thing"
" as ``OR('Org1.member', 'Org2.member')``."
msgstr ""
"策略``OutOf(1, 'Org1.member', 'Org2.member')``的解析结果和``OR('Org1.member', "
"'Org2.member')``是一样的。"

#: ../../source/endorsement-policies.rst:159
msgid ""
"Similarly, ``OutOf(2, 'Org1.member', 'Org2.member')`` is equivalent to "
"``AND('Org1.member', 'Org2.member')``, and ``OutOf(2, 'Org1.member', "
"'Org2.member', 'Org3.member')`` is equivalent to ``OR(AND('Org1.member', "
"'Org2.member'), AND('Org1.member', 'Org3.member'), AND('Org2.member', "
"'Org3.member'))``."
msgstr ""
"类似地，``OutOf(2, 'Org1.member', 'Org2.member')``等价于``AND('Org1.member', "
"'Org2.member')``，并且``OutOf(2, 'Org1.member', 'Org2.member', "
"'Org3.member')``等价于``OR(AND('Org1.member', 'Org2.member'), "
"AND('Org1.member', 'Org3.member'), AND('Org2.member', 'Org3.member'))``。"

#: ../../source/endorsement-policies.rst:168
msgid "Setting key-level endorsement policies"
msgstr "设置键级别背书策略"

#: ../../source/endorsement-policies.rst:170
msgid ""
"Setting regular chaincode-level endorsement policies is tied to the "
"lifecycle of the corresponding chaincode. They can only be set or modified "
"when instantiating or upgrading the corresponding chaincode on a channel."
msgstr "设置常规的链码级背书策略与相应链码的生命周期相关联。它们只能在实例化时，或者升级通道上相应的链码时，设置或修改。"

#: ../../source/endorsement-policies.rst:174
msgid ""
"In contrast, key-level endorsement policies can be set and modified in a "
"more granular fashion from within a chaincode. The modification is part of "
"the read-write set of a regular transaction."
msgstr "相反，键级别背书策略可以在链码中以更细粒度的方式设置和修改。修改是常规交易读写集的一部分。"

#: ../../source/endorsement-policies.rst:178
msgid ""
"The shim API provides the following functions to set and retrieve an "
"endorsement policy for/from a regular key."
msgstr "shim API提供了以下函数来设置和检索常规键的背书策略。"

#: ../../source/endorsement-policies.rst:181
msgid ""
"``ep`` below stands for the \"endorsement policy\", which can be expressed "
"either by using the same syntax described above or by using the convenience "
"function described below. Either method will generate a binary version of "
"the endorsement policy that can be consumed by the basic shim API."
msgstr ""
"下面的``ep``代表\"背书策略\"，可以使用上面描述的相同语法来表示，也可以使用下面描述的便利函数来表示。这两种方法都将生成可由基本shim "
"API使用的背书策略的二进制版本。"

#: ../../source/endorsement-policies.rst:192
msgid ""
"For keys that are part of :doc:`private-data/private-data` in a collection "
"the following functions apply:"
msgstr "对于私有数据集合中属于:doc:`private-data/private-data`的键，应用以下函数："

#: ../../source/endorsement-policies.rst:200
msgid ""
"To help set endorsement policies and marshal them into validation parameter "
"byte arrays, the Go shim provides an extension with convenience functions "
"that allow the chaincode developer to deal with endorsement policies in "
"terms of the MSP identifiers of organizations, see `KeyEndorsementPolicy "
"<https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim/ext/statebased#KeyEndorsementPolicy>`_:"
msgstr ""
"为了辅助设置背书策略，并把策略封装成可验证的字节数组形式的参数，Go "
"shim提供了便利的可扩展函数，这些函数允许链码开发人员根据组织的MSP标识符处理背书策略。查看 `KeyEndorsementPolicy "
"<https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim/ext/statebased#KeyEndorsementPolicy>`_："

#: ../../source/endorsement-policies.rst:223
msgid ""
"For example, to set an endorsement policy for a key where two specific orgs "
"are required to endorse the key change, pass both org ``MSPIDs`` to "
"``AddOrgs()``, and then call ``Policy()`` to construct the endorsement "
"policy byte array that can be passed to ``SetStateValidationParameter()``."
msgstr ""
"例如，要为一个键设置背书策略，其中需要两个特定的组织来背书键的更改，请将两个组织的``MSPIDs``传递给``AddOrgs()``，然后调用``Policy()``来构造可传递给``SetStateValidationParameter()``的字节数组形式的背书策略。"

#: ../../source/endorsement-policies.rst:228
msgid ""
"To add the shim extension to your chaincode as a dependency, see "
":ref:`vendoring`."
msgstr "要将shim扩展作为依赖项添加到链码中，请参见:ref:`vendoring`。"

#: ../../source/endorsement-policies.rst:231
#: ../../source/endorsement-policies.rst:238
msgid "Validation"
msgstr "验证"

#: ../../source/endorsement-policies.rst:233
msgid ""
"At commit time, setting a value of a key is no different from setting the "
"endorsement policy of a key --- both update the state of the key and are "
"validated based on the same rules."
msgstr "在提交时，设置键的值与设置键的背书策略没有什么不同——两者都更新键的状态，并基于相同的规则进行验证。"

#: ../../source/endorsement-policies.rst:238
msgid "no validation parameter set"
msgstr "no validation parameter set"

#: ../../source/endorsement-policies.rst:238
msgid "validation parameter set"
msgstr "validation parameter set"

#: ../../source/endorsement-policies.rst:240
msgid "modify value"
msgstr "modify value"

#: ../../source/endorsement-policies.rst:240
#: ../../source/endorsement-policies.rst:242
msgid "check chaincode ep"
msgstr "check chaincode ep"

#: ../../source/endorsement-policies.rst:240
#: ../../source/endorsement-policies.rst:242
msgid "check key-level ep"
msgstr "check key-level ep"

#: ../../source/endorsement-policies.rst:242
msgid "modify key-level ep"
msgstr "modify key-level ep"

#: ../../source/endorsement-policies.rst:245
msgid ""
"As we discussed above, if a key is modified and no key-level endorsement "
"policy is present, the chaincode-level endorsement policy applies by "
"default. This is also true when a key-level endorsement policy is set for a "
"key for the first time --- the new key-level endorsement policy must first "
"be endorsed according to the pre-existing chaincode-level endorsement "
"policy."
msgstr ""
"正如我们在上面讨论的，如果修改了键对应的值，并且不存在键级别的背书策略，则默认应用链码级别的背书策略。当第一次为键设置键级别背书策略时也是如此——新的键级别背书策略必须首先根据已存在的链码级背书策略进行背书。"

#: ../../source/endorsement-policies.rst:251
msgid ""
"If a key is modified and a key-level endorsement policy is present, the key-"
"level endorsement policy overrides the chaincode-level endorsement policy. "
"In practice, this means that the key-level endorsement policy can be either "
"less restrictive or more restrictive than the chaincode-level endorsement "
"policy. Because the chaincode-level endorsement policy must be satisfied in "
"order to set a key-level endorsement policy for the first time, no trust "
"assumptions have been violated."
msgstr ""
"如果修改了键对应的值，并且设置了键级别的背书策略，则键级别的背书策略将覆盖链码级别的背书策略。实际上，这意味着键级别背书策略的限制可以比链码级背书策略更少，也可以更多。由于在首次设置键级别背书策略时，必须满足链码级背书策略，因此并没有违反任何信任设定。"

#: ../../source/endorsement-policies.rst:258
msgid ""
"If a key's endorsement policy is removed (set to nil), the chaincode-level "
"endorsement policy becomes the default again."
msgstr "如果删除了键的键级别背书策略（设置为nil），则链码级的背书策略再次成为默认值。"

#: ../../source/endorsement-policies.rst:261
msgid ""
"If a transaction modifies multiple keys with different associated key-level "
"endorsement policies, all of these policies need to be satisfied in order "
"for the transaction to be valid."
msgstr "如果交易修改多个键的值，各个键关联不同的键级别背书策略，则需要满足所有这些策略才能使交易有效。"
