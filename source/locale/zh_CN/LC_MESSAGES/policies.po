# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# JulienGuo郭立冬 <690748277@qq.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-23 09:48+0800\n"
"PO-Revision-Date: 2019-04-22 19:58+0000\n"
"Last-Translator: JulienGuo郭立冬 <690748277@qq.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/hyperledger/teams/97220/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/policies.rst:2
msgid "Policies in Hyperledger Fabric"
msgstr "Hyperledger Fabric中的策略"

#: ../../source/policies.rst:4
msgid ""
"Configuration for a Hyperledger Fabric blockchain network is managed by "
"policies. These policies generally reside in the channel configuration. The "
"primary purpose of this document is to explain how policies are defined in "
"and interact with the channel configuration. However, policies may also be "
"specified in some other places, such as chaincodes, so this information may "
"be of interest outside the scope of channel configuration."
msgstr ""
"Hyperledger Fabric "
"区块链网络的配置是由策略管理的。这些策略通常属于通道配置。本文档的主要目的是解释策略在通道配置中是如何定义的，以及策略是如何与通道配置交互的。但是，策略也可以在其他一些地方指定，比如链码，因此本文档的这些信息可能超出了通道配置的范围。"

#: ../../source/policies.rst:13
msgid "What is a Policy?"
msgstr "什么是策略？"

#: ../../source/policies.rst:15
msgid ""
"At its most basic level, a policy is a function which accepts as input a set"
" of signed data and evaluates successfully, or returns an error because some"
" aspect of the signed data did not satisfy the policy."
msgstr "在最基本的层次上，策略是一个函数，它接受一组带签名的数据作为输入，然后运算成功，或者因为带签名数据的某些方面不满足策略而返回一个错误。"

#: ../../source/policies.rst:19
msgid ""
"More concretely, policies test whether the signer or signers of some data "
"meet some condition required for those signatures to be considered 'valid'. "
"This is useful for determining that the correct parties have agreed to a "
"transaction, or change."
msgstr ""
"更具体地说，策略为了判断某些数据的签名是否“有效”，而测试数据的签名者是否满足某些必要的条件。这用来判断正确的参与方是否同意进行交易或更改。"

#: ../../source/policies.rst:24
msgid ""
"For example a policy may define any of the following: \\* Administrators "
"from 2 out 5 possible different organizations must sign. \\* Any member from"
" any organization must sign. \\* Two specific certificates must both sign."
msgstr ""
"例如，策略可以定义成以下任意一种：\\*必须有5个不同组织中的2个组织的管理员签名。\\*任何组织的任何成员都必须签名。\\*两个指定的身份证书必须都签名。"

#: ../../source/policies.rst:29
msgid ""
"Of course these are only examples, and other more powerful rules can be "
"constructed."
msgstr "当然，这些只是示例，还可以构造其他更强大的规则。"

#: ../../source/policies.rst:33
msgid "Policy Types"
msgstr "策略类型"

#: ../../source/policies.rst:35
msgid "There are presently two different types of policies implemented:"
msgstr "目前实现的策略有两种："

#: ../../source/policies.rst:37
msgid ""
"**SignaturePolicy**: This policy type is the most powerful, and specifies "
"the policy as a combination of evaluation rules for MSP Principals. It "
"supports arbitrary combinations of *AND*, *OR*, and *NOutOf*, allowing the "
"construction of extremely powerful rules like: \"An admin of org A and 2 "
"other admins, or 11 of 20 org admins\"."
msgstr ""
"**SignaturePolicy**：签名策略，这种策略类型是最强大的，它将策略指定为MSP主体的评估规则的组合。它支持*AND*、*OR*、*NOutOf*的任意组合，允许构造极其强大的规则，比如：“组织A的一个管理员和2个其他管理员，或20个组织中的11个组织的管理员”。"

#: ../../source/policies.rst:42
msgid ""
"**ImplicitMetaPolicy**: This policy type is less flexible than "
"SignaturePolicy, and is only valid in the context of configuration. It "
"aggregates the result of evaluating policies deeper in the configuration "
"hierarchy, which are ultimately defined by SignaturePolicies. It supports "
"good default rules like \"A majority of the organization admin policies\"."
msgstr ""
"**ImplicitMetaPolicy**：隐式的元策略，这种策略类型不如SignaturePolicy灵活，并且只在配置的上下文中有效。它在配置层次结构中更深入地聚合了评估策略的结果，这种聚合结果最终由SignaturePolicies定义。它支持良好的默认规则，比如“组织管理策略的大多数”。"

#: ../../source/policies.rst:49
msgid ""
"Policies are encoded in a ``common.Policy`` message as defined in "
"``fabric/protos/common/policies.proto``. They are defined by the following "
"message:"
msgstr ""
"策略编码为``common.Policy``消息，定义在``fabric/protos/common/policies.proto``中。它们由以下消息定义："

#: ../../source/policies.rst:66
msgid ""
"To encode the policy, simply pick the policy type of either ``SIGNATURE`` or"
" ``IMPLICIT_META``, set it to the ``type`` field, and marshal the "
"corresponding policy implementation proto to ``policy``."
msgstr ""
"要对策略进行编码，只需选择``SIGNATURE``或``IMPLICIT_META``的策略类型，将其设置为``type``字段的值，并根据相应的策略实现proto序列化成``policy``。"

#: ../../source/policies.rst:71
msgid "Configuration and Policies"
msgstr "配置和策略"

#: ../../source/policies.rst:73
msgid ""
"The channel configuration is expressed as a hierarchy of configuration "
"groups, each of which has a set of values and policies associated with them."
" For a validly configured application channel with two application "
"organizations and one ordering organization, the configuration looks "
"minimally as follows:"
msgstr ""
"通道配置由层次结构的配置组的表示，每个组都有一些与之关联的值和策略。对于具有两个应用程序组织和一个排序组织的有效配置的应用通道，配置看起来最少如下所示："

#: ../../source/policies.rst:115
msgid ""
"Consider the Writers policy referred to with the ``------->`` mark in the "
"above example. This policy may be referred to by the shorthand notation "
"``/Channel/Application/Writers``. Note that the elements resembling "
"directory components are group names, while the last component resembling a "
"file basename is the policy name."
msgstr ""
"考虑上面示例中使用 ``------->`` 标记引用的Writers策略。这个策略可以用简写符号 "
"``/Channel/Application/Writers``来引用。注意，与目录相似的元素是组名，而与文件名相似的最后一个组件是策略名。"

#: ../../source/policies.rst:121
msgid ""
"Different components of the system will refer to these policy names. For "
"instance, to call ``Deliver`` on the orderer, the signature on the request "
"must satisfy the ``/Channel/Readers`` policy. However, to gossip a block to "
"a peer will require that the ``/Channel/Application/Readers`` policy be "
"satisfied."
msgstr ""
"系统的不同组件要参考这些策略名称。例如，要调用排序者的``Deliver``，请求上的签名必须满足``/Channel/Readers``策略。然而，向节点Gossip同步一个区块需要满足``/Channel/Application/Readers``的策略。"

#: ../../source/policies.rst:127
msgid ""
"By setting these different policies, the system can be configured with rich "
"access controls."
msgstr "通过设置这些不同的策略，系统可以配置丰富的访问控制。"

#: ../../source/policies.rst:131
msgid "Constructing a SignaturePolicy"
msgstr "构造一个SignaturePolicy"

#: ../../source/policies.rst:133
msgid "As with all policies, the SignaturePolicy is expressed as protobuf."
msgstr "与所有策略一样，SignaturePolicy也是用protobuf表示。"

#: ../../source/policies.rst:154
msgid ""
"The outer ``SignaturePolicyEnvelope`` defines a version (currently only "
"``0`` is supported), a set of identities expressed as ``MSPPrincipal``\\ s ,"
" and a ``policy`` which defines the policy rule, referencing the "
"``identities`` by index. For more details on how to specify MSP Principals, "
"see the MSP Principals section."
msgstr ""
"外部的``SignaturePolicyEnvelope``定义了一个版本（目前只支持``0`` ），一组表示为``MSPPrincipal``\\ "
"s的身份标识，以及一个``policy``定义策略规则，通过索引引用``identities``。有关如何指定MSP主体的详细信息，请参阅MSP主体部分。"

#: ../../source/policies.rst:160
msgid ""
"The ``SignaturePolicy`` is a recursive data structure which either "
"represents a single signature requirement from a specific ``MSPPrincipal``, "
"or a collection of ``SignaturePolicy``\\ s, requiring that ``N`` of them are"
" satisfied."
msgstr ""
"``SignaturePolicy``是一个递归的数据结构，它要么表示来自特定``MSPPrincipal``的单个签名需求，要么表示 "
"``SignaturePolicy``\\ s的集合，要求满足其中的``N``。"

#: ../../source/policies.rst:165
msgid "For example:"
msgstr "例如："

#: ../../source/policies.rst:183
msgid ""
"This defines a signature policy over MSP Principals ``mspP1`` and ``mspP2``."
" It requires both that there is a signature satisfying ``mspP1`` and a "
"signature satisfying ``mspP2``."
msgstr ""
"这在MSP主体``mspP1``和``mspP2``上定义了一个签名策略。它要求同时有一个满足``mspP1``的签名和一个满足``mspP2``的签名。"

#: ../../source/policies.rst:187
msgid "As another more complex example:"
msgstr "另一个更复杂的例子是："

#: ../../source/policies.rst:213
msgid ""
"This defines a signature policy over MSP Principals ``mspP1``, ``mspP2``, "
"and ``mspP3``. It requires one signature which satisfies ``mspP1``, and "
"another signature which either satisfies ``mspP2`` or ``mspP3``."
msgstr ""
"这在MSP主体``mspP1``、``mspP2``、``mspP3``上定义了一个签名策略。它要求一个签名满足``mspP1``，并且还有一个签名满足``mspP2``或者``mspP3``。"

#: ../../source/policies.rst:218
msgid ""
"Hopefully it is clear that complicated and relatively arbitrary logic may be"
" expressed using the SignaturePolicy policy type. For code which constructs "
"signature policies, consult ``fabric/common/cauthdsl/cauthdsl_builder.go``."
msgstr ""
"希望可以清楚地看到，可以使用SignaturePolicy策略类型来表示复杂且相对比较任意的逻辑。对于构造签名策略SignaturePolicy的代码，查看``fabric/common/cauthdsl/cauthdsl_builder.go``。"

#: ../../source/policies.rst:225
msgid ""
"**Limitations**: When evaluating a signature policy against a signature set,"
" signatures are 'consumed', in the order in which they appear, regardless of"
" whether they satisfy multiple policy principals."
msgstr ""
"**限制**：当根据签名集合评估其是否满足策略时，（系统）按签名出现的顺序评估其是否满足策略，排序在前的签名评估后会被标记为'已消费'，不管该签名是否满足策略后续出现的更多主体。"

#: ../../source/policies.rst:229
msgid "For example.  Consider a policy which requires"
msgstr "例如，考虑一个需要的策略"

#: ../../source/policies.rst:235
msgid ""
"The naive intent of this policy is to require that both an admin, and a "
"member sign. For the signature set"
msgstr "此策略的原始意图是要求同时具有一个管理员和一个成员的签名。对于签名集"

#: ../../source/policies.rst:242
msgid ""
"the policy evaluates to true, just as expected.  However, consider the "
"signature set"
msgstr "这个策略的评估结果是True，跟预想的一样。但是，考虑这个签名集："

#: ../../source/policies.rst:249
msgid ""
"This signature set does not satisfy the policy.  This failure is because "
"when ``org1.AdminSignature`` satisfies the ``org1.Member`` role it is "
"considered 'consumed' by the ``org1.Member`` requirement.  Because the "
"``org1.Admin`` principal cannot be satisfied by the "
"``org1.MemberSignature``, the policy evaluates to false."
msgstr ""
"这个签名集不满足这个策略。评估失败是因为当 ``org1.AdminSignature`` "
"满足``org1.Member``的角色之后，会被系统标记为'已消费'，它被认为是满足了普通成员的需求。 因为``org1.Admin``主体不能被 "
"``org1.MemberSignature``满足，所以整个策略评估结果为false。"

#: ../../source/policies.rst:255
msgid ""
"To avoid this pitfall, identities should be specified from most privileged "
"to least privileged in the policy identities specification, and signatures "
"should be ordered from least privileged to most privileged in the signature "
"set."
msgstr ""
"为了避免这个陷阱，应该在策略中把身份标识顺序指定成从权限最高的身份到权限最低的身份，并且应该在签名集中从权限最低的身份的签名排到权限最高的身份的签名。"

#: ../../source/policies.rst:260
msgid "MSP Principals"
msgstr "MSP主体"

#: ../../source/policies.rst:262
msgid ""
"The MSP Principal is a generalized notion of cryptographic identity. "
"Although the MSP framework is designed to work with types of cryptography "
"other than X.509, for the purposes of this document, the discussion will "
"assume that the underlying MSP implementation is the default MSP type, based"
" on X.509 cryptography."
msgstr ""
"MSP主体是加密身份的一个广义概念。尽管MSP框架被设计的兼容处理X.509之外的加密类型，但出于本文档的目的，讨论将假定底层MSP实现是默认MSP类型"
"----基于X.509加密的。"

#: ../../source/policies.rst:268
msgid ""
"An MSP Principal is defined in ``fabric/protos/msp_principal.proto`` as "
"follows:"
msgstr "MSP主体在``fabric/protos/msp_principal.proto``中定义，如下："

#: ../../source/policies.rst:286
msgid ""
"The ``principal_classification`` must be set to either ``ROLE`` or "
"``IDENTITY``. The ``ORGANIZATIONAL_UNIT`` is at the time of this writing not"
" implemented."
msgstr ""
"``principal_classification``必须设置为``ROLE``或者``IDENTITY``。``ORGANIZATIONAL_UNIT``目前还没有实现。"

#: ../../source/policies.rst:290
msgid ""
"In the case of ``IDENTITY`` the ``principal`` field is set to the bytes of a"
" certificate literal."
msgstr "在``IDENTITY``的情况下，``principal``字段被设置为证书的字节流内容。"

#: ../../source/policies.rst:293
msgid ""
"However, more commonly the ``ROLE`` type is used, as it allows the principal"
" to match many different certs issued by the MSP's certificate authority."
msgstr "但是，``ROLE``用的更多一些，因为这种类型允许主体匹配很多MSP的CA颁发的不同的证书。"

#: ../../source/policies.rst:297
msgid ""
"In the case of ``ROLE``, the ``principal`` is a marshaled ``MSPRole`` "
"message defined as follows:"
msgstr "在``ROLE``的情况下，``principal``是一个序列化之后的``MSPRole``消息，定义如下："

#: ../../source/policies.rst:315
msgid ""
"The ``msp_identifier`` is set to the ID of the MSP (as defined by the "
"``MSPConfig`` proto in the channel configuration for an org) which will "
"evaluate the signature, and the ``Role`` is set to either ``MEMBER``, "
"``ADMIN``, ``CLIENT`` or ``PEER``. In particular:"
msgstr ""
"``msp_identifier``被设置为MSP的ID（由``MSPConfig`` "
"proto在通道配置中为组织定义），它对应的公钥将用来评估是否匹配签名的结果，``Role``被设置为``MEMBER``、``ADMIN``、``CLIENT``或``PEER``四值之一。特别是："

#: ../../source/policies.rst:320
msgid "``MEMBER`` matches any certificate issued by the MSP."
msgstr "``MEMBER`` 可以匹配MSP签署的任何证书。"

#: ../../source/policies.rst:321
msgid ""
"``ADMIN`` matches certificates enumerated as admin in the MSP definition."
msgstr "``ADMIN`` 匹配MSP定义中被枚举为管理员的证书。"

#: ../../source/policies.rst:322
msgid ""
"``CLIENT`` (``PEER``) matches certificates that carry the client (peer) "
"Organizational unit."
msgstr "``CLIENT``（``PEER``）匹配代表客户端或者Peer的组织单位的证书。"

#: ../../source/policies.rst:324
msgid ""
"(see `MSP Documentation <http://hyperledger-"
"fabric.readthedocs.io/en/latest/msp.html>`_)"
msgstr ""
"（查看 `MSP Documentation <http://hyperledger-"
"fabric.readthedocs.io/en/latest/msp.html>`_）"

#: ../../source/policies.rst:327
msgid "Constructing an ImplicitMetaPolicy"
msgstr "构造一个ImplicitMetaPolicy"

#: ../../source/policies.rst:329
msgid ""
"The ``ImplicitMetaPolicy`` is only validly defined in the context of channel"
" configuration. It is ``Implicit`` because it is constructed implicitly "
"based on the current configuration, and it is ``Meta`` because its "
"evaluation is not against MSP principals, but rather against other policies."
" It is defined in ``fabric/protos/common/policies.proto`` as follows:"
msgstr ""
"``ImplicitMetaPolicy`` "
"仅在通道配置的上下文中定义才有效。它是``Implicit隐式的``，因为它是基于当前配置隐式（此处译者有疑问）构造的；它是``Meta元``的，因为它的计算不是针对MSP主体的，而是针对其他策略的（此处译者有疑问）。它在``fabric/protos/common/policies.proto``"
" 中定义。如下："

#: ../../source/policies.rst:348
msgid "For example, consider a policy defined at ``/Channel/Readers`` as"
msgstr "例如，考虑一个给``/Channel/Readers`定义的策略："

#: ../../source/policies.rst:357
msgid ""
"This policy will implicitly select the sub-groups of ``/Channel``, in this "
"case, ``Application`` and ``Orderer``, and retrieve the policy of name "
"``foo``, to give the policies ``/Channel/Application/foo`` and "
"``/Channel/Orderer/foo``. Then, when the policy is evaluated, it will check "
"to see if ``ANY`` of those two policies evaluate without error. Had the rule"
" been ``ALL`` it would require both."
msgstr ""
"该策略将隐式地选择``/Channel``的子组，在本例中为``Application``和``Orderer``，在选择的组内检索名称为``foo``的策略，得到``/Channel/Application/foo``和`/Channel/Orderer/foo``。然后，当对策略进行评估时，它将检查这两个策略中的``ANY``，即任何一个，是否没有报错。如果规则是``ALL``，那就需要两者都没有报错。"

#: ../../source/policies.rst:364
msgid ""
"Consider another policy defined at ``/Channel/Application/Writers`` where "
"there are 3 application orgs defined, ``OrgA``, ``OrgB``, and ``OrgC``."
msgstr ""
"考虑一个给``/Channel/Application/Writers``定义的策略，包含三个组织``OrgA``、``OrgB``、``OrgC``。"

#: ../../source/policies.rst:375
msgid ""
"In this case, the policies collected would be "
"``/Channel/Application/OrgA/bar``, ``/Channel/Application/OrgB/bar``, and "
"``/Channel/Application/OrgC/bar``. Because the rule requires a ``MAJORITY``,"
" this policy will require that 2 of the three organization's ``bar`` "
"policies are satisfied."
msgstr ""
"在本例中，能被检索出来的策略总共有``/Channel/Application/OrgA/bar``、``/Channel/Application/OrgB/bar``、``/Channel/Application/OrgC/bar``。因为规则是要``MAJORITY``多数原则，本策略就需要满足三个组织里面的至少两个子策略。"

#: ../../source/policies.rst:382
msgid "Policy Defaults"
msgstr "默认策略"

#: ../../source/policies.rst:384
msgid "The ``configtxgen`` tool creates default policies as follows:"
msgstr "``configtxgen``按如下方式工具创建默认策略："

#: ../../source/policies.rst:405
msgid ""
"Note that policies higher in the hierarchy are all defined as "
"``ImplicitMetaPolicy``\\ s while leaf nodes necessarily are defined as "
"``SignaturePolicy``\\ s. This set of defaults works nicely because the "
"``ImplicitMetaPolicies`` do not need to be redefined as the number of "
"organizations change, and the individual organizations may pick their own "
"rules and thresholds for what is means to be a Reader, Writer, and Admin."
msgstr ""
"注意，层级高的策略都是定义为``ImplicitMetaPolicy``\\ "
"s，只有在最低一级的叶节点才有必要定义``SignaturePolicy``\\ "
"s。这组默认值效果良好，``ImplicitMetaPolicies``不需要因为组织的数量变化而重新定义，具体组织可以选择他们自己的规则和阈值来决定怎样才能成为一个Reader、Writer或者Admin这样的角色。"
