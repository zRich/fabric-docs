# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 王伟兵 <wbwang@inspur.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-01 12:09+0800\n"
"PO-Revision-Date: 2019-04-22 20:00+0000\n"
"Last-Translator: 王伟兵 <wbwang@inspur.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/hyperledger/teams/97220/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/developapps/smartcontract.md:1
msgid "Smart Contract Processing"
msgstr ""

#: ../../source/developapps/smartcontract.md:3
msgid "Audience: Architects, Application and smart contract developers"
msgstr "受众:架构师、应用程序和聪智能合约开发者"

#: ../../source/developapps/smartcontract.md:5
msgid ""
"At the heart of a blockchain network is a smart contract. In PaperNet, the "
"code in the commercial paper smart contract defines the valid states for "
"commercial paper, and the transaction logic that transition a paper from one"
" state to another. In this topic, we're going to show you how to implement a"
" real world smart contract that governs the process of issuing, buying and "
"redeeming commercial paper."
msgstr ""
"在区块链网络的核心是一个智能合约。在PaperNet中，商业票据智能合约中的代码定义了商业票据的有效状态，以及将票据从一种状态转换到另一种状态的交易逻辑。在本主题中，我们将向您展示如何实现一个管理商业票据发行、购买和赎回过程的真实世界智能合约。"

#: ../../source/developapps/smartcontract.md:12
msgid "We're going to cover:"
msgstr "我们会讲到:"

#: ../../source/developapps/smartcontract.md:14
msgid "What is a smart contract and why it's important"
msgstr ""

#: ../../source/developapps/smartcontract.md:15
msgid "How to define a smart contract"
msgstr ""

#: ../../source/developapps/smartcontract.md:16
msgid "How to define a transaction"
msgstr ""

#: ../../source/developapps/smartcontract.md:17
msgid "How to implement a transaction"
msgstr ""

#: ../../source/developapps/smartcontract.md:18
msgid "How to represent a business object in a smart contract"
msgstr ""

#: ../../source/developapps/smartcontract.md:19
msgid "How to store and retrieve an object in the ledger"
msgstr ""

#: ../../source/developapps/smartcontract.md:21
msgid ""
"If you'd like, you can download the sample and even run it locally. It is "
"written in JavaScript, but the logic is quite language independent, so "
"you'll be easily able to see what's going on! (The sample will become "
"available for Java and GOLANG as well.)"
msgstr ""
"如果您愿意，可以下载示例，甚至在本地运行它。它是用JavaScript编写的，但是逻辑是完全独立于语言的，所以您可以很容易地看到发生了什么！(Java和GOLANG也将提供该示例。)"

#: ../../source/developapps/smartcontract.md:26
msgid "Smart Contract"
msgstr ""

#: ../../source/developapps/smartcontract.md:28
msgid ""
"A smart contract defines the different states of a business object and "
"governs the processes that move the object between these different states. "
"Smart contracts are important because they allow architects and smart "
"contract developers to define the key business processes and data that are "
"shared across the different organizations collaborating in a blockchain "
"network."
msgstr ""
"智能合约定义业务对象的不同状态，并管理对象在这些不同状态之间移动的流程。智能合约非常重要，因为它们允许架构师和智能合约开发者定义关键业务流程和数据，在区块链网络中跨组织协作。"

#: ../../source/developapps/smartcontract.md:34
msgid ""
"In the PaperNet network, the smart contract is shared by the different "
"network participants, such as MagnetoCorp and DigiBank.  The same version of"
" the smart contract must be used by all applications connected to the "
"network so that they jointly implement the same shared business processes "
"and data."
msgstr ""
"在PaperNet网络中，智能合约由不同的网络参与者共享，如MagnetoCorp和DigiBank。所有连接到网络的应用程序都必须使用相同版本的智能合约，以便它们共同实现相同的共享业务流程和数据。"

#: ../../source/developapps/smartcontract.md:39
msgid "Contract class"
msgstr ""

#: ../../source/developapps/smartcontract.md:41
msgid ""
"A copy of the PaperNet commercial paper smart contract is contained in "
"papercontract.js. View it with your browser, or open it in your favourite "
"editor if you've downloaded it."
msgstr ""
"PaperNet商业票据智能合约的副本包含在papercontract.js中。用你的浏览器查看它，或者在你最喜欢的编辑器中打开它（如果你已经下载了它）。"

#: ../../source/developapps/smartcontract.md:46
msgid ""
"You may notice from the file path that this is MagnetoCorp's copy of the "
"smart contract.  MagnetoCorp and DigiBank must agree the version of the "
"smart contract that they are going to use. For now, it doesn't matter which "
"organization's copy you look at, they are all the same."
msgstr ""
"您可能从文件路径中注意到，这是MagnetoCorp的智能合约副本。MagnetoCorp和DigiBank必须就它们将使用的智能合约版本达成一致。现在，不管你看的是哪个组织的副本，它们都是一样的。"

#: ../../source/developapps/smartcontract.md:51
msgid ""
"Spend a few moments looking at the overall structure of the smart contract; "
"notice that it's quite short! Towards the top of papercontract.js, you'll "
"see that there's a definition for the commercial paper smart contract:"
msgstr "花点时间看看智能合约的整体结构;注意，它相当短！在 papercontract.js的顶部，你会看到商业票据智能合约有一个定义:"

#: ../../source/developapps/smartcontract.md:59
msgid ""
"The CommercialPaperContract class contains the transaction definitions for "
"commercial paper -- issue, buy and redeem. It's these transactions that "
"bring commercial papers into existence and move them through their "
"lifecycle. We'll examine these transactions soon, but for now notice how "
"CommercialPaperContract extends the Hyperledger Fabric Contract class. This "
"built-in class, and the Context class, were brought into scope earlier:"
msgstr ""
"CommercialPaperContract类包含商业票据的交易定义——发行、购买和赎回。正是这些交易使商业票据得以存在，并在其生命周期中移动它们。我们将很快研究这些交易，但现在请注意"
" CommercialPaperContract是如何扩展超级账本Fabric Contract类的。这个内置类和上下文类在前面已经介绍过:"

#: ../../source/developapps/smartcontract.md:73
msgid ""
"Our commercial paper contract will use built-in features of these classes, "
"such as automatic method invocation, a per-transaction context, transaction "
"handlers, and class-shared state."
msgstr "我们的商业票据合约将使用这些类的内置特性，例如自动方法调用、每个交易上下文、交易处理程序和类共享状态。"

#: ../../source/developapps/smartcontract.md:78
msgid ""
"Notice also how the class constructor uses its superclass to initialize "
"itself with an explicit contract name:"
msgstr "还请注意类构造函数如何使用它的超类用显式的合约名初始化自己:"

#: ../../source/developapps/smartcontract.md:88
msgid ""
"Most importantly, org.papernet.commercialpaper is very descriptive -- this "
"smart contract is the agreed definition of commercial paper for all PaperNet"
" organizations."
msgstr ""
"最重要的是，org.papernet.commercialpaper非常具有描述性——这个智能合约是所有PaperNet组织对商业票据的一致定义。"

#: ../../source/developapps/smartcontract.md:92
msgid ""
"Usually there will only be one smart contract per file -- contracts tend to "
"have different lifecycles, which makes it sensible to separate them. "
"However, in some cases, multiple smart contracts might provide syntactic "
"help for applications, e.g. EuroBond, DollarBond, YenBond, but essentially "
"provide the same function. In such cases, smart contracts and transactions "
"can be disambiguated."
msgstr ""
"通常每个文件只有一个智能合约——合约往往有不同的生命周期，因此将它们分开是明智的。然而，在某些情况下，多个智能合约可能为应用程序提供语法帮助，例如EuroBond、DollarBond、YenBond，但本质上提供相同的功能。在这种情况下，可以消除智能合约和交易的歧义。"

#: ../../source/developapps/smartcontract.md:98
msgid "Transaction definition"
msgstr ""

#: ../../source/developapps/smartcontract.md:100
msgid "Within the class, locate the issue method."
msgstr "在类中，找到issue方法。"

#: ../../source/developapps/smartcontract.md:106
msgid ""
"This function is given control whenever this contract is called to issue a "
"commercial paper. Recall how commercial paper 00001 was created with the "
"following transaction:"
msgstr "每当调用此合约以发行商业票据时，都会对该函数进行控制。回想一下商业票据00001是如何通过以下交易创建的:"

#: ../../source/developapps/smartcontract.md:119
msgid ""
"We've changed the variable names for programming style, but see how these "
"properties map almost directly to the issue method variables."
msgstr "我们已经为编程风格更改了变量名，但是看看这些属性如何几乎直接映射到issue方法变量。"

#: ../../source/developapps/smartcontract.md:122
msgid ""
"The issue method is automatically given control by the contract whenever an "
"application makes a request to issue a commercial paper. The transaction "
"property values are made available to the method via the corresponding "
"variables. See how an application submits a transaction using the "
"Hyperledger Fabric SDK in the application topic, using a sample application "
"program."
msgstr ""
"每当应用程序请求发出商业票据时，合约自动地赋予issue方法控制权。交易属性值通过相应的变量提供给方法。查看一个应用如何使用示例应用程序，在应用主题中使用超级账本Fabric"
" SDK提交交易。"

#: ../../source/developapps/smartcontract.md:129
msgid ""
"You might have noticed an extra variable in the issue definition -- ctx. "
"It's called the transaction context, and it's always first. By default, it "
"maintains both per-contract and per-transaction information relevant to "
"transaction logic. For example, it would contain MagnetoCorp's specified "
"transaction identifier, a MagnetoCorp issuing user's digital certificate, as"
" well as access to the ledger API."
msgstr ""
"您可能已经注意到了issue定义中的一个额外变量——ctx。它被称为交易上下文，它总是第一个。默认情况下，它同时维护与交易逻辑相关的每个合约和每个交易的信息。例如，它将包含MagnetoCorp指定的交易标识符、MagnetoCorp发行的用户数字证书、以及对账本API的访问。"

#: ../../source/developapps/smartcontract.md:136
msgid ""
"See how the smart contract extends the default transaction context by "
"implementing its own createContext() method rather than accepting the "
"default implementation:"
msgstr "查看智能合约如何通过实现自己的createContext()方法扩展默认交易上下文，而不是接受默认实现:"

#: ../../source/developapps/smartcontract.md:146
msgid ""
"This extended context adds a custom property paperList to the defaults:"
msgstr "此扩展上下文将自定义属性paperList添加到默认值:"

#: ../../source/developapps/smartcontract.md:158
msgid ""
"We'll soon see how ctx.paperList can be subsequently used to help store and "
"retrieve all PaperNet commercial papers."
msgstr "我们很快就会看到ctx.paperList随后可用于帮助存储和检索所有PaperNet商业票据。"

#: ../../source/developapps/smartcontract.md:161
msgid ""
"To solidify your understanding of the structure of a smart contract "
"transaction, locate the buy and redeem transaction definitions, and see if "
"you can see how they map to their corresponding commercial paper "
"transactions."
msgstr "要巩固对智能合约交易结构的理解，请找到购买和赎回交易定义，并查看它们如何映射到相应的商业票据交易。"

#: ../../source/developapps/smartcontract.md:165
msgid "The buy transaction:"
msgstr "购买交易："

#: ../../source/developapps/smartcontract.md:181
msgid "The redeem transaction:"
msgstr "赎回交易："

#: ../../source/developapps/smartcontract.md:195
msgid ""
"In both cases, observe the 1:1 correspondence between the commercial paper "
"transaction and the smart contract method definition.  And don't worry about"
" the async and await keywords -- they allow asynchronous JavaScript "
"functions to be treated like their synchronous cousins in other programming "
"languages."
msgstr ""
"在这两种情况下，观察商业票据交易与智能合约方法定义之间的1:1对应关系。不要担心异步，等待关键字——它们允许将异步JavaScript函数像其他编程语言中的同步函数一样对待。"

#: ../../source/developapps/smartcontract.md:203
msgid "Transaction logic"
msgstr ""

#: ../../source/developapps/smartcontract.md:205
msgid ""
"Now that you've seen how contracts are structured and transactions are "
"defined, let's focus on the logic within the smart contract."
msgstr "现在您已经了解了合约的结构和交易的定义，让我们将重点放在智能合约中的逻辑上。"

#: ../../source/developapps/smartcontract.md:208
msgid "Recall the first issue transaction:"
msgstr "回想第一个发行交易:"

#: ../../source/developapps/smartcontract.md:219
msgid "It results in the issue method being passed control:"
msgstr "它导致issue方法被传递控制:"

#: ../../source/developapps/smartcontract.md:241
msgid ""
"The logic is simple: take the transaction input variables, create a new "
"commercial paper paper, add it to the list of all commercial papers using "
"paperList, and return the new commercial paper (serialized as a buffer) as "
"the transaction response."
msgstr ""
"逻辑很简单:获取交易输入变量，创建一个新的商业票据，使用paperList将其添加到所有商业票据的列表中，并返回新的商业票据(作为缓冲序列化)作为交易响应。"

#: ../../source/developapps/smartcontract.md:246
msgid ""
"See how paperList is retrieved from the transaction context to provide "
"access to the list of commercial papers. issue(), buy() and redeem() "
"continually re-access ctx.paperList to keep the list of commercial papers "
"up-to-date."
msgstr ""
"请参阅如何从交易上下文检索paperList以提供对商业票据列表的访问。 issue()、buy() 和redeem() "
"不断地重新访问ctx.paperList，以保持最新的商业票据清单。"

#: ../../source/developapps/smartcontract.md:250
msgid "The logic for the buy transaction is a little more elaborate:"
msgstr "购买交易的逻辑更为复杂:"

#: ../../source/developapps/smartcontract.md:282
msgid ""
"See how the transaction checks currentOwner and that paper is TRADING before"
" changing the owner with paper.setOwner(newOwner). The basic flow is simple "
"though -- check some pre-conditions, set the new owner, update the "
"commercial paper on the ledger, and return the updated commercial paper "
"(serialized as a buffer) as the transaction response."
msgstr ""
"在使用paper. setowner "
"(newOwner)更改所有者之前，查看交易怎样检查currentOwner和正在交易的票据是否一致。基本流程很简单——检查一些先决条件，设置新所有者，更新账本上的商业票据，并将更新后的商业票据(序列化为缓冲)作为交易响应返回。"

#: ../../source/developapps/smartcontract.md:288
msgid ""
"Why don't you see if you can understand the logic for the redeem "
"transaction?"
msgstr "为什么不看看您是否理解赎回交易的逻辑?"

#: ../../source/developapps/smartcontract.md:291
msgid "Representing an object"
msgstr ""

#: ../../source/developapps/smartcontract.md:293
msgid ""
"We've seen how to define and implement the issue, buy and redeem "
"transactions using the CommercialPaper and PaperList classes. Let's end this"
" topic by seeing how these classes work."
msgstr ""
"我们已经了解了如何使用CommercialPaper和PaperList类定义和实现发行、购买和赎回交易。让我们通过了解这些类如何工作来结束这个主题。"

#: ../../source/developapps/smartcontract.md:297
msgid "Locate the CommercialPaper class in the paper.js file:"
msgstr "在paper.js文件中找到CommercialPaper类:"

#: ../../source/developapps/smartcontract.md:304
msgid ""
"This class contains the in-memory representation of a commercial paper "
"state. See how the createInstance method initializes a new commercial paper "
"with the provided parameters:"
msgstr "该类包含商业票据状态的内存表示形式。查看createInstance方法如何使用提供的参数初始化新的商业票据:"

#: ../../source/developapps/smartcontract.md:314
msgid "Recall how this class was used by the issue transaction:"
msgstr "回想一下这个类是如何被发行交易使用的:"

#: ../../source/developapps/smartcontract.md:320
msgid ""
"See how every time the issue transaction is called, a new in-memory instance"
" of a commercial paper is created containing the transaction data."
msgstr "查看每次调用发行交易时，如何创建包含交易数据的新的商业票据内存实例。"

#: ../../source/developapps/smartcontract.md:323
msgid "A few important points to note:"
msgstr "以下几点需要注意:"

#: ../../source/developapps/smartcontract.md:325
msgid ""
"This is an in-memory representation; we'll see later how it appears on the "
"ledger."
msgstr ""

#: ../../source/developapps/smartcontract.md:329
msgid ""
"The CommercialPaper class extends the State class. State is an application-"
"defined class which creates a common abstraction for a state. All states "
"have a business object class which they represent, a composite key, can be "
"serialized and de-serialized, and so on.  State helps our code be more "
"legible when we are storing more than one business object type on the "
"ledger. Examine the State class in the state.js file."
msgstr ""

#: ../../source/developapps/smartcontract.md:338
msgid ""
"A paper computes its own key when it is created -- this key will be used "
"when the ledger is accessed. The key is formed from a combination of issuer "
"and paperNumber."
msgstr ""

#: ../../source/developapps/smartcontract.md:350
msgid ""
"A paper is moved to the ISSUED state by the transaction, not by the paper "
"class. That's because it's the smart contract that governs the lifecycle "
"state of the paper. For example, an import transaction might create a new "
"set of papers immediately in the TRADING state."
msgstr ""

#: ../../source/developapps/smartcontract.md:355
msgid "The rest of the CommercialPaper class contains simple helper methods:"
msgstr "CommercialPaper类的其余部分包含简单的辅助方法:"

#: ../../source/developapps/smartcontract.md:363
msgid ""
"Recall how methods like this were used by the smart contract to move the "
"commercial paper through its lifecycle. For example, in the redeem "
"transaction we saw:"
msgstr "回想一下智能合约如何使用这样的方法来移动商业票据通过生命周期。例如，在赎回交易中我们看到:"

#: ../../source/developapps/smartcontract.md:374
msgid "Access the ledger"
msgstr ""

#: ../../source/developapps/smartcontract.md:376
msgid "Now locate the PaperList class in the paperlist.js file:"
msgstr "现在在paperlist.js文件中找到PaperList类:"

#: ../../source/developapps/smartcontract.md:383
msgid ""
"This utility class is used to manage all PaperNet commercial papers in "
"Hyperledger Fabric state database. The PaperList data structures are "
"described in more detail in the architecture topic."
msgstr ""
"这个实用程序类用于管理超级账本Fabric状态数据库中的所有PaperNet商业票据。PaperList数据结构在架构主题中有更详细的描述。"

#: ../../source/developapps/smartcontract.md:387
msgid ""
"Like the CommercialPaper class, this class extends an application-defined "
"StateList class which creates a common abstraction for a list of states -- "
"in this case, all the commercial papers in PaperNet."
msgstr ""
"与CommercialPaper类一样，该类扩展了应用程序定义的StateList类，该类为状态列表创建公共抽象——在本例中，是PaperNet中的所有商业票据。"

#: ../../source/developapps/smartcontract.md:391
msgid ""
"The addPaper() method is a simple veneer over the StateList.addState() "
"method:"
msgstr "addPaper()方法是 StateList.addState()方法上的一个简单装饰:"

#: ../../source/developapps/smartcontract.md:400
msgid ""
"You can see in the StateList.js file how the StateList class uses the Fabric"
" API putState() to write the commercial paper as state data in the ledger:"
msgstr ""
"您可以在StateList.js文件中看到StateList类如何使用Fabric API putState()将商业票据作为状态数据写入账本:"

#: ../../source/developapps/smartcontract.md:413
msgid ""
"Every piece of state data in a ledger requires these two fundamental "
"elements:"
msgstr ""
"账本中的每一项状态数据都需要这两个基本要素:\n"
"- 键: 键由createCompositeKey()组成，使用固定的名称和状态键。构造PaperList对象时分配了名称，state. getsplitkey()确定每个状态的唯一键。\n"
"- 数据:数据只是商业票据状态的序列化形式，使用State.serialize()实用程序方法创建。State类使用JSON序列化和反序列化数据，State的业务对象类(在我们的例子中是CommercialPaper)根据需要在构造PaperList对象时再次设置。"

#: ../../source/developapps/smartcontract.md:415
msgid ""
"Key: key is formed with createCompositeKey() using a fixed name and the key "
"of state. The name was assigned when the PaperList object was constructed, "
"and state.getSplitKey() determines each state's unique key."
msgstr ""

#: ../../source/developapps/smartcontract.md:420
msgid ""
"Data: data is simply the serialized form of the commercial paper state, "
"created using the State.serialize() utility method. The State class "
"serializes and deserializes data using JSON, and the State's business object"
" class as required, in our case CommercialPaper, again set when the "
"PaperList object was constructed."
msgstr ""

#: ../../source/developapps/smartcontract.md:427
msgid ""
"Notice how a StateList doesn't store anything about an individual state or "
"the total list of states -- it delegates all of that to the Fabric state "
"database. This is an important design pattern -- it reduces the opportunity "
"for ledger MVCC collisions in Hyperledger Fabric."
msgstr ""
"请注意，StateList不存储关于单个状态或状态总列表的任何信息——它将所有这些委托给Fabric状态数据库。这是一个重要的设计模式——它减少了在超级账本Fabric中发生账本MVCC冲突的机会。"

#: ../../source/developapps/smartcontract.md:432
msgid ""
"The StateList getState() and updateState() methods work in similar ways:"
msgstr "StateList getState()和updateState()方法的工作方式类似:"

#: ../../source/developapps/smartcontract.md:451
msgid ""
"See how they use the Fabric APIs putState(), getState() and "
"createCompositeKey() to access the ledger. We'll expand this smart contract "
"later to list all commercial papers in paperNet -- what might the method "
"look like to implement this ledger retrieval?"
msgstr ""
"查看他们如何使用Fabric api "
"putState()、getState()和createCompositeKey()访问账本。稍后，我们将扩展这个智能合约，列出paperNet中的所有商业票据——实现这种账本检索的方法可能是什么样的?"

#: ../../source/developapps/smartcontract.md:456
msgid ""
"That's it! In this topic you've understood how to implement the smart "
"contract for PaperNet.  You can move to the next sub topic to see how an "
"application calls the smart contract using the Fabric SDK."
msgstr ""
"就是这样!在本主题中，您已经了解了如何实现PaperNet的智能合约。您可以转到下一个子主题，了解应用程序如何使用Fabric SDK调用智能合约。"
